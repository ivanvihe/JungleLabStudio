       # utils/settings_manager.py - FIXED MIDI MAPPINGS LOADING - COMPLETE VERSION
    1: import json
    1: import os
    1: import logging
       
    2: class SettingsManager:
    1:     def __init__(self, settings_file='config/settings.json'):
    1:         self.settings_file = settings_file
               # Archivo separado para mapeos MIDI
    1:         self.mappings_file = 'config/midi_mappings.json'
    1:         self.settings = self.load_settings()
               
               # Set default values if they don't exist
    1:         self.ensure_defaults()
       
    1:     def ensure_defaults(self):
               """Ensure default settings exist"""
    1:         defaults = {
    1:             "control_panel_monitor": 0,
    1:             "main_window_monitor": 0,
    1:             "last_midi_device": "virtual 20",
    1:             "auto_save_settings": True,
    1:             "window_positions": {
    1:                 "control_panel": {"x": 50, "y": 50, "width": 1200, "height": 800},
    1:                 "main_window": {"x": 100, "y": 100, "width": 800, "height": 600}
                   },
    1:             "deck_settings": {
    1:                 "deck_a": {
    1:                     "last_visualizer": "",
    1:                     "last_controls": {}
                       },
    1:                 "deck_b": {
    1:                     "last_visualizer": "",
    1:                     "last_controls": {}
                       }
                   },
    1:             "mixer_settings": {
    1:                 "last_mix_value": 50,
    1:                 "crossfader_curve": "linear"
                   },
    1:             "audio_settings": {
    1:                 "input_device": "",
    1:                 "buffer_size": 1024,
    1:                 "sample_rate": 44100
                   },
    1:             "visual_settings": {
    1:                 "fps_limit": 60,
    1:                 "vsync": True,
    1:                 "quality": "high"
                   },
    1:             "midi_mappings": {}  # Default empty MIDI mappings
               }
               
               # Add missing defaults
   11:         for key, value in defaults.items():
   10:             if key not in self.settings:
                       self.settings[key] = value
                       
               # Save updated settings
    1:         self.save_settings()
       
    1:     def load_settings(self):
               """Load settings from file"""
    1:         try:
    1:             if os.path.exists(self.settings_file):
    2:                 with open(self.settings_file, 'r', encoding='utf-8') as f:
    1:                     settings = json.load(f)
    1:                 logging.debug(f"Loaded settings from {self.settings_file}")
    1:                 return settings
                   else:
                       logging.debug(f"Settings file {self.settings_file} not found, using defaults")
                       return {}
               except Exception as e:
                   logging.error(f"Error loading settings: {e}")
                   return {}
       
    1:     def save_settings(self):
               """Save settings to file"""
    4:         try:
    4:             os.makedirs(os.path.dirname(self.settings_file), exist_ok=True)
    8:             with open(self.settings_file, 'w', encoding='utf-8') as f:
    4:                 json.dump(self.settings, f, indent=4, ensure_ascii=False)
    4:             logging.debug(f"Settings saved to {self.settings_file}")
               except Exception as e:
                   logging.error(f"Error saving settings: {e}")
       
    1:     def get_setting(self, key, default=None):
               """Get a setting value with optional default"""
    7:         try:
                   # Support nested keys like "deck_settings.deck_a.last_visualizer"
    7:             if '.' in key:
    3:                 keys = key.split('.')
    3:                 value = self.settings
    9:                 for k in keys:
    6:                     value = value.get(k, {})
    3:                 return value if value != {} else default
                   else:
    4:                 return self.settings.get(key, default)
               except Exception as e:
                   logging.error(f"Error getting setting {key}: {e}")
                   return default
       
    1:     def set_setting(self, key, value):
               """Set a setting value"""
    3:         try:
                   # Support nested keys
    3:             if '.' in key:
    2:                 keys = key.split('.')
    2:                 current = self.settings
                       
                       # Navigate to the nested location, creating dicts as needed
    4:                 for k in keys[:-1]:
    2:                     if k not in current:
                               current[k] = {}
    2:                     current = current[k]
                       
                       # Set the final value
    2:                 current[keys[-1]] = value
                   else:
    1:                 self.settings[key] = value
                   
                   # Auto-save if enabled
    3:             if self.get_setting("auto_save_settings", True):
    3:                 self.save_settings()
                       
    3:             logging.debug(f"Setting {key} set to {value}")
               except Exception as e:
                   logging.error(f"Error setting {key}: {e}")
       
    1:     def get_window_position(self, window_name):
               """Get saved window position and size"""
    2:         return self.get_setting(f"window_positions.{window_name}", {})
       
    1:     def set_window_position(self, window_name, x, y, width, height):
               """Save window position and size"""
    2:         position_data = {"x": x, "y": y, "width": width, "height": height}
    2:         self.set_setting(f"window_positions.{window_name}", position_data)
       
    1:     def get_deck_setting(self, deck_id, setting_name, default=None):
               """Get a deck-specific setting"""
               return self.get_setting(f"deck_settings.{deck_id}.{setting_name}", default)
       
    1:     def set_deck_setting(self, deck_id, setting_name, value):
               """Set a deck-specific setting"""
               self.set_setting(f"deck_settings.{deck_id}.{setting_name}", value)
       
    1:     def get_mixer_setting(self, setting_name, default=None):
               """Get a mixer-specific setting"""
               return self.get_setting(f"mixer_settings.{setting_name}", default)
       
    1:     def set_mixer_setting(self, setting_name, value):
               """Set a mixer-specific setting"""
               self.set_setting(f"mixer_settings.{setting_name}", value)
       
    1:     def export_settings(self, export_path):
               """Export settings to a different file"""
               try:
                   with open(export_path, 'w', encoding='utf-8') as f:
                       json.dump(self.settings, f, indent=4, ensure_ascii=False)
                   logging.info(f"Settings exported to {export_path}")
                   return True
               except Exception as e:
                   logging.error(f"Error exporting settings: {e}")
                   return False
       
    1:     def import_settings(self, import_path):
               """Import settings from a file"""
               try:
                   with open(import_path, 'r', encoding='utf-8') as f:
                       imported_settings = json.load(f)
                   
                   # Merge with current settings (imported takes precedence)
                   self.settings.update(imported_settings)
                   self.save_settings()
                   logging.info(f"Settings imported from {import_path}")
                   return True
               except Exception as e:
                   logging.error(f"Error importing settings: {e}")
                   return False
       
    1:     def reset_to_defaults(self):
               """Reset all settings to defaults"""
               self.settings = {}
               self.ensure_defaults()
               logging.info("Settings reset to defaults")
       
    1:     def get_all_settings(self):
               """Get a copy of all settings"""
    1:         return self.settings.copy()
       
    1:     def get_monitor_settings(self):
               """Get monitor assignment settings"""
               return {
                   "control_panel_monitor": self.get_setting("control_panel_monitor", 0),
                   "main_window_monitor": self.get_setting("main_window_monitor", 0)
               }
       
    1:     def set_monitor_settings(self, control_panel_monitor=None, main_window_monitor=None):
               """Set monitor assignment settings"""
               if control_panel_monitor is not None:
                   self.set_setting("control_panel_monitor", control_panel_monitor)
               if main_window_monitor is not None:
                   self.set_setting("main_window_monitor", main_window_monitor)
       
           # --- FUNCIONES MIDI MEJORADAS PARA PRIORIZAR config/midi_mappings.json ---
    1:     def load_midi_mappings(self):
               """FIXED: Load MIDI mappings with priority to config/midi_mappings.json"""
               try:
                   logging.info("üíæ LOADING MIDI MAPPINGS...")
                   
                   # CRITICAL FIX: First try to load from config/midi_mappings.json (standalone file)
                   # This is the PRIMARY source that should override everything else
                   if os.path.exists(self.mappings_file):
                       logging.info(f"üìÅ Trying to load from PRIMARY source: {self.mappings_file}")
                       try:
                           with open(self.mappings_file, 'r', encoding='utf-8') as f:
                               file_mappings = json.load(f)
                           
                           if isinstance(file_mappings, dict) and len(file_mappings) > 0:
                               logging.info(f"‚úÖ SUCCESS: Loaded {len(file_mappings)} MIDI mappings from {self.mappings_file}")
                               
                               # Debug: mostrar algunos mappings cargados
                               for action_id, mapping_data in list(file_mappings.items())[:5]:
                                   midi_key = mapping_data.get('midi', 'no_midi')
                                   action_type = mapping_data.get('type', 'unknown')
                                   params = mapping_data.get('params', {})
                                   logging.info(f"   {action_id}: {midi_key} -> {action_type} {params}")
                               
                               # Also save to settings for backup
                               self.set_setting("midi_mappings", file_mappings)
                               return file_mappings
                           else:
                               logging.warning(f"‚ö†Ô∏è Empty or invalid mappings in {self.mappings_file}")
                               
                       except json.JSONDecodeError as e:
                           logging.error(f"‚ùå JSON decode error in {self.mappings_file}: {e}")
                       except Exception as e:
                           logging.error(f"‚ùå Error reading {self.mappings_file}: {e}")
                   else:
                       logging.warning(f"‚ö†Ô∏è PRIMARY mappings file {self.mappings_file} not found")
                   
                   # FALLBACK: Try to load from main settings file
                   logging.info("üìÅ Trying fallback: load from settings file...")
                   mappings = self.get_setting("midi_mappings", {})
                   
                   if isinstance(mappings, dict) and len(mappings) > 0:
                       logging.info(f"‚úÖ FALLBACK: Loaded {len(mappings)} MIDI mappings from settings")
                       # Save to primary file for future use
                       try:
                           os.makedirs(os.path.dirname(self.mappings_file), exist_ok=True)
                           with open(self.mappings_file, 'w', encoding='utf-8') as f:
                               json.dump(mappings, f, indent=4, ensure_ascii=False)
                           logging.info(f"‚úÖ Mappings also saved to primary file: {self.mappings_file}")
                       except Exception as e:
                           logging.warning(f"‚ö†Ô∏è Could not save to primary file: {e}")
                       return mappings
                   else:
                       logging.warning("‚ö†Ô∏è No valid MIDI mappings found in settings either")
                       return {}
                       
               except Exception as e:
                   logging.error(f"‚ùå Critical error loading MIDI mappings: {e}")
                   import traceback
                   traceback.print_exc()
                   return {}
       
    1:     def save_midi_mappings(self, mappings):
               """FIXED: Save MIDI mappings to BOTH primary file AND settings"""
               try:
                   if not isinstance(mappings, dict):
                       logging.error("‚ùå Invalid mappings format, must be a dictionary")
                       return
                       
                   logging.info(f"üíæ SAVING {len(mappings)} MIDI mappings...")
                   
                   # PRIORITY 1: Save to primary config file (config/midi_mappings.json)
                   try:
                       os.makedirs(os.path.dirname(self.mappings_file), exist_ok=True)
                       with open(self.mappings_file, 'w', encoding='utf-8') as f:
                           json.dump(mappings, f, indent=4, ensure_ascii=False)
                       logging.info(f"‚úÖ PRIMARY: Saved to {self.mappings_file}")
                   except Exception as e:
                       logging.error(f"‚ùå Failed to save to primary file {self.mappings_file}: {e}")
                   
                   # BACKUP: Also save to main settings
                   try:
                       self.set_setting("midi_mappings", mappings)
                       logging.info(f"‚úÖ BACKUP: Saved to settings file")
                   except Exception as e:
                       logging.error(f"‚ùå Failed to save to settings: {e}")
                       
                   logging.info(f"‚úÖ MIDI mappings saved successfully")
                       
               except Exception as e:
                   logging.error(f"‚ùå Critical error saving MIDI mappings: {e}")
       
    1:     def get_midi_device_settings(self):
               """Get MIDI device settings"""
               return {
                   'last_device': self.get_setting("last_midi_device", ""),
                   'auto_connect': self.get_setting("midi_auto_connect", True),
                   'learn_timeout': self.get_setting("midi_learn_timeout", 10)
               }
       
    1:     def set_midi_device_settings(self, device_settings):
               """Set MIDI device settings"""
               try:
                   for key, value in device_settings.items():
                       if key == 'last_device':
                           self.set_setting("last_midi_device", value)
                       elif key == 'auto_connect':
                           self.set_setting("midi_auto_connect", value)
                       elif key == 'learn_timeout':
                           self.set_setting("midi_learn_timeout", value)
                   logging.info("MIDI device settings updated")
               except Exception as e:
                   logging.error(f"Error setting MIDI device settings: {e}")
       
    1:     def export_midi_mappings(self, filename):
               """Export MIDI mappings to a file"""
               try:
                   mappings = self.load_midi_mappings()
                   with open(filename, 'w', encoding='utf-8') as f:
                       json.dump(mappings, f, indent=2, ensure_ascii=False)
                   logging.info(f"MIDI mappings exported to {filename}")
                   return True
               except Exception as e:
                   logging.error(f"Error exporting MIDI mappings: {e}")
                   return False
       
    1:     def import_midi_mappings(self, filename):
               """Import MIDI mappings from a file"""
               try:
                   with open(filename, 'r', encoding='utf-8') as f:
                       mappings = json.load(f)
                   if isinstance(mappings, dict):
                       self.save_midi_mappings(mappings)
                       logging.info(f"MIDI mappings imported from {filename}")
                       return True
                   else:
                       logging.error("Invalid file format for MIDI mappings")
                       return False
               except Exception as e:
                   logging.error(f"Error importing MIDI mappings: {e}")
                   return False
       
           # --- FUNCIONES ADICIONALES PARA MANEJO DE CONFIGURACIONES ---
           
    1:     def get_audio_settings(self):
               """Get audio settings"""
               return {
                   'input_device': self.get_setting("audio_settings.input_device", ""),
                   'buffer_size': self.get_setting("audio_settings.buffer_size", 1024),
                   'sample_rate': self.get_setting("audio_settings.sample_rate", 44100)
               }
       
    1:     def set_audio_settings(self, audio_settings):
               """Set audio settings"""
               try:
                   for key, value in audio_settings.items():
                       self.set_setting(f"audio_settings.{key}", value)
                   logging.info("Audio settings updated")
               except Exception as e:
                   logging.error(f"Error setting audio settings: {e}")
       
    1:     def get_visual_settings(self):
               """Get visual settings"""
               return {
                   'fps_limit': self.get_setting("visual_settings.fps_limit", 60),
                   'vsync': self.get_setting("visual_settings.vsync", True),
                   'quality': self.get_setting("visual_settings.quality", "high")
               }
       
    1:     def set_visual_settings(self, visual_settings):
               """Set visual settings"""
               try:
                   for key, value in visual_settings.items():
                       self.set_setting(f"visual_settings.{key}", value)
                   logging.info("Visual settings updated")
               except Exception as e:
                   logging.error(f"Error setting visual settings: {e}")
       
    1:     def backup_settings(self, backup_path=None):
               """Create a backup of all settings"""
               try:
                   if backup_path is None:
                       import datetime
                       timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
                       backup_path = f"config/settings_backup_{timestamp}.json"
                   
                   return self.export_settings(backup_path)
               except Exception as e:
                   logging.error(f"Error creating settings backup: {e}")
                   return False
       
    1:     def restore_settings(self, backup_path):
               """Restore settings from a backup"""
               try:
                   return self.import_settings(backup_path)
               except Exception as e:
                   logging.error(f"Error restoring settings from backup: {e}")
                   return False
       
    1:     def validate_settings(self):
               """Validate current settings for consistency"""
               try:
                   issues = []
                   
                   # Check required settings
                   required_settings = [
                       "control_panel_monitor",
                       "main_window_monitor", 
                       "window_positions",
                       "deck_settings",
                       "mixer_settings",
                       "audio_settings",
                       "visual_settings"
                   ]
                   
                   for setting in required_settings:
                       if setting not in self.settings:
                           issues.append(f"Missing required setting: {setting}")
                   
                   # Check window positions
                   if "window_positions" in self.settings:
                       for window_name, pos in self.settings["window_positions"].items():
                           required_pos_keys = ["x", "y", "width", "height"]
                           for key in required_pos_keys:
                               if key not in pos:
                                   issues.append(f"Missing {key} in window_positions.{window_name}")
                   
                   # Check deck settings
                   if "deck_settings" in self.settings:
                       for deck_id in ["deck_a", "deck_b"]:
                           if deck_id not in self.settings["deck_settings"]:
                               issues.append(f"Missing deck_settings.{deck_id}")
                   
                   if issues:
                       logging.warning(f"Settings validation found {len(issues)} issues:")
                       for issue in issues:
                           logging.warning(f"  - {issue}")
                       return False
                   else:
                       logging.info("Settings validation passed")
                       return True
                       
               except Exception as e:
                   logging.error(f"Error validating settings: {e}")
                   return False
       
    1:     def cleanup_old_settings(self):
               """Remove old or unused settings to keep file clean"""
               try:
                   # List of deprecated settings that can be safely removed
                   deprecated_settings = [
                       "old_midi_device",
                       "legacy_audio_settings",
                       "deprecated_visual_options"
                   ]
                   
                   removed_count = 0
                   for setting in deprecated_settings:
                       if setting in self.settings:
                           del self.settings[setting]
                           removed_count += 1
                   
                   if removed_count > 0:
                       self.save_settings()
                       logging.info(f"Cleaned up {removed_count} deprecated settings")
                   
                   return removed_count
                   
               except Exception as e:
                   logging.error(f"Error cleaning up settings: {e}")
                   return 0
       
    1:     def get_settings_summary(self):
               """Get a summary of current settings for debugging"""
               try:
                   summary = {
                       'total_settings': len(self.settings),
                       'midi_mappings_count': len(self.get_setting("midi_mappings", {})),
                       'has_window_positions': 'window_positions' in self.settings,
                       'audio_device': self.get_setting("audio_settings.input_device", "Not set"),
                       'midi_device': self.get_setting("last_midi_device", "Not set"),
                       'auto_save_enabled': self.get_setting("auto_save_settings", False),
                       'visual_quality': self.get_setting("visual_settings.quality", "Not set")
                   }
                   
                   return summary
                   
               except Exception as e:
                   logging.error(f"Error getting settings summary: {e}")
                   return {}
       
    1:     def __str__(self):
               """String representation for debugging"""
               summary = self.get_settings_summary()
               return f"SettingsManager(settings: {summary.get('total_settings', 0)}, midi_mappings: {summary.get('midi_mappings_count', 0)})"
