       # ui/control_panel_window.py - ACTUALIZADO CON NUEVA UI MIDI
    1: import logging
    1: from PyQt6.QtWidgets import (
           QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, QComboBox,
           QGroupBox, QGridLayout, QFrame, QProgressBar, QMenuBar, QMenu, QFormLayout, QApplication,
           QMessageBox, QTextEdit, QScrollArea, QSplitter, QTabWidget, QTableWidget, QTableWidgetItem,
           QHeaderView, QDialog, QDialogButtonBox
       )
    1: from PyQt6.QtCore import Qt, QTimer, QMutex, QMutexLocker, QSize
    1: from PyQt6.QtGui import QAction, QFont, QColor
       
    1: from .preferences_dialog import PreferencesDialog
    1: from .midi_config_widget import MidiConfigWidget
    1: from .layout_sections import create_header_section, create_footer_section
    1: from .live_control_tab import create_live_control_tab
    1: from .monitor_tab import create_monitor_tab
    1: from .midi_config_tab import create_midi_config_tab
       
    2: class ControlPanelWindow(QMainWindow):
    1:     def __init__(self, mixer_window, settings_manager, midi_engine, visualizer_manager, audio_analyzer):
    1:         super().__init__(mixer_window)
    1:         logging.debug("ControlPanelWindow.__init__ called - CON NUEVA UI MIDI")
               
               # Store references
    1:         self.mixer_window = mixer_window
    1:         self.settings_manager = settings_manager
    1:         self.midi_engine = midi_engine
    1:         self.visualizer_manager = visualizer_manager
    1:         self.audio_analyzer = audio_analyzer
       
               # Thread safety
    1:         self._mutex = QMutex()
               
               # Estado de actividad MIDI en tiempo real
    1:         self.deck_a_status = {
    1:             'active_preset': None,
    1:             'last_activity': None,
    1:             'controls': {'intensity': 0, 'speed': 0, 'color': 0}
               }
               
    1:         self.deck_b_status = {
    1:             'active_preset': None,
    1:             'last_activity': None,
    1:             'controls': {'intensity': 0, 'speed': 0, 'color': 0}
               }
               
    1:         self.mix_status = {
    1:             'crossfader_value': 50,
    1:             'last_mix_action': None,
    1:             'last_activity': None
               }
               
    1:         self.setWindowTitle("Audio Visualizer Pro - MIDI Control Center (Enhanced)")
    1:         self.setGeometry(50, 50, 1600, 900)
               
               # Create menu bar
    1:         self.create_menu_bar()
       
               # Create main UI - REDISE√ëADO CON NUEVA UI MIDI
    1:         self.create_enhanced_ui()
               
               # Connect MIDI signals for activity monitoring
    1:         self.setup_midi_connections()
               
               # Connect audio signals
    1:         self.setup_audio_connections()
               
               # Timer for updating system information
    1:         self.update_timer = QTimer()
    1:         self.update_timer.timeout.connect(self.update_info)
    1:         self.update_timer.start(100)  # 10 FPS for UI updates
       
    1:     def setup_midi_connections(self):
               """Setup MIDI signal connections"""
    1:         try:
    1:             if hasattr(self.midi_engine, 'midi_message_received'):
    2:                 self.midi_engine.midi_message_received.connect(
    1:                     self.on_midi_activity, Qt.ConnectionType.QueuedConnection
                       )
    1:             if hasattr(self.midi_engine, 'note_on_received'):
    2:                 self.midi_engine.note_on_received.connect(
    1:                     self.on_note_activity, Qt.ConnectionType.QueuedConnection
                       )
    1:             if hasattr(self.midi_engine, 'control_changed'):
    2:                 self.midi_engine.control_changed.connect(
    1:                     self.on_cc_activity, Qt.ConnectionType.QueuedConnection
                       )
    1:             if hasattr(self.midi_engine, 'device_connected'):
    2:                 self.midi_engine.device_connected.connect(
    1:                     self.on_midi_device_connected, Qt.ConnectionType.QueuedConnection
                       )
    1:             if hasattr(self.midi_engine, 'device_disconnected'):
    2:                 self.midi_engine.device_disconnected.connect(
    1:                     self.on_midi_device_disconnected, Qt.ConnectionType.QueuedConnection
                       )
    1:             if hasattr(self.midi_engine, 'preset_loaded_on_deck'):
    2:                 self.midi_engine.preset_loaded_on_deck.connect(
    1:                     self.on_preset_loaded_on_deck, Qt.ConnectionType.QueuedConnection
                       )
               except Exception as e:
                   logging.warning(f"Could not connect MIDI activity signals: {e}")
       
    1:     def setup_audio_connections(self):
               """Setup audio signal connections"""
    1:         try:
    1:             if hasattr(self.audio_analyzer, 'level_changed'):
    1:                 self.audio_analyzer.level_changed.connect(self.update_audio_level)
    1:             if hasattr(self.audio_analyzer, 'fft_data_ready'):
    1:                 self.audio_analyzer.fft_data_ready.connect(self.update_frequency_bands)
               except Exception as e:
                   logging.warning(f"Could not connect audio signals: {e}")
       
    1:     def create_menu_bar(self):
    1:         menubar = self.menuBar()
               
               # Settings menu
    1:         settings_menu = menubar.addMenu('Settings')
               
    1:         preferences_action = QAction('Preferences...', self)
    1:         preferences_action.triggered.connect(self.show_preferences)
    1:         settings_menu.addAction(preferences_action)
       
               # MIDI menu - MEJORADO
    1:         midi_menu = menubar.addMenu('MIDI')
               
    1:         midi_config_action = QAction('üéπ Configuraci√≥n MIDI Completa...', self)
    1:         midi_config_action.triggered.connect(self.show_midi_config)
    1:         midi_menu.addAction(midi_config_action)
               
    1:         midi_menu.addSeparator()
               
    1:         test_mappings_action = QAction('Test MIDI Mappings', self)
    1:         test_mappings_action.triggered.connect(self.test_midi_mappings)
    1:         midi_menu.addAction(test_mappings_action)
               
    1:         print_mappings_action = QAction('Print Current Mappings', self)
    1:         print_mappings_action.triggered.connect(self.print_midi_mappings)
    1:         midi_menu.addAction(print_mappings_action)
               
    1:         midi_menu.addSeparator()
               
    1:         debug_midi_action = QAction('üîß Debug MIDI Connection', self)
    1:         debug_midi_action.triggered.connect(self.run_midi_debug)
    1:         midi_menu.addAction(debug_midi_action)
       
               # View menu
    1:         view_menu = menubar.addMenu('View')
               
    1:         refresh_action = QAction('Refresh Devices', self)
    1:         refresh_action.triggered.connect(self.refresh_devices)
    1:         view_menu.addAction(refresh_action)
       
    1:     def create_enhanced_ui(self):
               """Create the enhanced UI with MIDI configuration integrated"""
    1:         main_widget = QWidget()
    1:         self.setCentralWidget(main_widget)
               
               # Main layout
    1:         main_layout = QVBoxLayout(main_widget)
    1:         main_layout.setSpacing(10)
    1:         main_layout.setContentsMargins(10, 10, 10, 10)
               
               # Header Section
    1:         header_section = create_header_section(self)
    1:         main_layout.addWidget(header_section)
       
               # Main Content: Tabs para mejor organizaci√≥n
    1:         main_tabs = QTabWidget()
       
               # Tab 1: Control en Vivo
    1:         live_tab = create_live_control_tab(self)
    1:         main_tabs.addTab(live_tab, "üéõÔ∏è Control en Vivo")
       
               # Tab 2: Configuraci√≥n MIDI
    1:         midi_tab = create_midi_config_tab(self)
    1:         main_tabs.addTab(midi_tab, "üéπ Configuraci√≥n MIDI")
       
               # Tab 3: Monitoreo y Debug
    1:         monitor_tab = create_monitor_tab(self)
    1:         main_tabs.addTab(monitor_tab, "üìä Monitoreo")
       
    1:         main_layout.addWidget(main_tabs)
       
               # Footer: Information panel
    1:         footer_section = create_footer_section(self)
    1:         main_layout.addWidget(footer_section)
       
    1:     def turn_on_midi_led(self):
               """Encender LED de actividad MIDI"""
   14:         try:
   14:             self.midi_led.setStyleSheet("""
                       QLabel {
                           color: #00ff00;
                           font-size: 16px;
                           font-weight: bold;
                           background-color: transparent;
                           border-radius: 8px;
                           min-width: 16px;
                           max-width: 16px;
                           text-align: center;
                       }
                   """)
   14:             self.midi_led_timer.start(100)
               except Exception as e:
                   logging.error(f"Error turning on MIDI LED: {e}")
       
    1:     def turn_off_midi_led(self):
               """Apagar LED de actividad MIDI"""
   14:         try:
   14:             self.midi_led.setStyleSheet("""
                       QLabel {
                           color: #333333;
                           font-size: 16px;
                           font-weight: bold;
                           background-color: transparent;
                           border-radius: 8px;
                           min-width: 16px;
                           max-width: 16px;
                           text-align: center;
                       }
                   """)
               except Exception as e:
                   logging.error(f"Error turning off MIDI LED: {e}")
       
       
       
       
    1:     def _add_row_to_table(self, table, timestamp, msg_type, data_str, max_rows=20):
               """Utility to append a row to a QTableWidget with limit"""
    9:         row = table.rowCount()
    9:         table.insertRow(row)
    9:         table.setItem(row, 0, QTableWidgetItem(timestamp))
    9:         table.setItem(row, 1, QTableWidgetItem(msg_type))
    9:         table.setItem(row, 2, QTableWidgetItem(data_str))
    9:         table.scrollToBottom()
    9:         if table.rowCount() > max_rows:
                   table.removeRow(0)
       
       
       
           # === FUNCIONES DE EVENTOS MIDI ===
       
    1:     def show_midi_config(self):
               """Mostrar configuraci√≥n MIDI completa"""
               try:
                   dialog = QDialog(self)
                   dialog.setWindowTitle("Configuraci√≥n MIDI Completa")
                   dialog.setModal(True)
                   dialog.resize(1200, 800)
                   
                   layout = QVBoxLayout(dialog)
                   
                   config_widget = MidiConfigWidget(
                       self.midi_engine, 
                       self.visualizer_manager, 
                       dialog
                   )
                   layout.addWidget(config_widget)
                   
                   # Bot√≥n cerrar
                   buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Close)
                   buttons.rejected.connect(dialog.accept)
                   layout.addWidget(buttons)
                   
                   dialog.exec()
                   
               except Exception as e:
                   logging.error(f"Error opening MIDI config: {e}")
                   QMessageBox.critical(self, "Error", f"Error abriendo configuraci√≥n: {str(e)}")
       
    1:     def test_mix_action(self, midi_key):
               """Probar acci√≥n de mix"""
               try:
                   if self.midi_engine:
                       # Simular mensaje MIDI
                       self.midi_engine.simulate_midi_message(midi_key)
                       logging.info(f"üß™ Testing mix action: {midi_key}")
               except Exception as e:
                   logging.error(f"Error testing mix action: {e}")
       
    1:     def clear_midi_activity(self):
               """Limpiar tabla de actividad MIDI"""
               try:
                   if hasattr(self, 'midi_activity_table'):
                       self.midi_activity_table.setRowCount(0)
                       self.midi_activity_data = []
                       self.midi_message_count = 0
               except Exception as e:
                   logging.error(f"Error clearing MIDI activity: {e}")
       
    1:     def toggle_midi_activity_monitoring(self):
               """Pausar/reanudar monitoreo MIDI"""
               try:
                   self.midi_monitoring_paused = not self.midi_monitoring_paused
                   # Implementar l√≥gica de pausa
               except Exception as e:
                   logging.error(f"Error toggling MIDI monitoring: {e}")
       
    1:     def clear_events_log(self):
               """Limpiar log de eventos"""
               try:
                   if hasattr(self, 'events_log'):
                       self.events_log.clear()
               except Exception as e:
                   logging.error(f"Error clearing events log: {e}")
       
    1:     def export_events_log(self):
               """Exportar log de eventos"""
               try:
                   # Implementar exportaci√≥n
                   QMessageBox.information(self, "Export", "Funcionalidad por implementar")
               except Exception as e:
                   logging.error(f"Error exporting events log: {e}")
       
    1:     def update_system_info(self):
               """Actualizar informaci√≥n del sistema"""
    1:         try:
    1:             if hasattr(self, 'system_info_text'):
    1:                 try:
    1:                     import psutil
    1:                     import platform
                           
    2:                     info = f"""Sistema: {platform.system()} {platform.release()}
    1: CPU: {psutil.cpu_percent()}%
    1: RAM: {psutil.virtual_memory().percent}%
    1: MIDI Engine: {'Activo' if self.midi_engine else 'Inactivo'}
    1: Mappings: {len(self.midi_engine.get_midi_mappings()) if self.midi_engine else 0}
       """
                       except ImportError:
                           import platform
                           info = f"""Sistema: Python {platform.python_version()}
       MIDI Engine: {'Activo' if self.midi_engine else 'Inactivo'}
       Mappings: {len(self.midi_engine.get_midi_mappings()) if self.midi_engine else 0}
       """
    1:                 self.system_info_text.setPlainText(info)
               except Exception as e:
                   logging.error(f"Error updating system info: {e}")
       
    1:     def on_midi_mappings_changed(self):
               """Manejar cambio de mappings MIDI"""
               try:
                   # Recargar informaci√≥n
                   self.update_mappings_info()
                   logging.info("MIDI mappings changed")
               except Exception as e:
                   logging.error(f"Error handling MIDI mappings change: {e}")
                   
    1:     def run_midi_debug(self):
               """Ejecutar debug completo de MIDI"""
               try:
                   logging.info("üîß USUARIO SOLICIT√ì DEBUG MIDI")
                   
                   if not self.midi_engine:
                       QMessageBox.warning(self, "Debug Error", "MIDI Engine no disponible")
                       return
                   
                   # Ejecutar debug
                   self.debug_midi_connection()
                   
                   # Mostrar resultado
                   QMessageBox.information(self, "Debug MIDI", 
                                         "Debug MIDI ejecutado.\nRevisa la consola para detalles completos.")
                   
               except Exception as e:
                   logging.error(f"Error en run_midi_debug: {e}")
                   QMessageBox.critical(self, "Error", f"Error ejecutando debug: {str(e)}")
       
    1:     def debug_midi_connection(self):
               """Debug completo de la conexi√≥n MIDI"""
               try:
                   logging.info("üîß INICIANDO DEBUG DE CONEXI√ìN MIDI")
                   logging.info("=" * 80)
                   
                   # 1. Verificar engine
                   if not self.midi_engine:
                       logging.error("‚ùå MIDI Engine no existe!")
                       return
                   
                   # 2. Verificar estado del puerto
                   logging.info("1. ESTADO DEL PUERTO MIDI:")
                   logging.info(f"   input_port: {self.midi_engine.input_port}")
                   logging.info(f"   running: {self.midi_engine.running}")
                   logging.info(f"   is_port_open(): {self.midi_engine.is_port_open()}")
                   
                   # 3. Puertos disponibles
                   logging.info("2. PUERTOS MIDI DISPONIBLES:")
                   available_ports = self.midi_engine.list_input_ports()
                   for i, port in enumerate(available_ports):
                       logging.info(f"   {i}: {port}")
                   
                   # 4. Verificar mappings
                   logging.info("3. VERIFICANDO MAPPINGS:")
                   logging.info(f"   Total mappings: {len(self.midi_engine.midi_mappings)}")
                   
                   # Mostrar mappings cr√≠ticos
                   critical_notes = [36, 37, 48, 54, 55, 69]  # Incluye A3 (69)
                   for note in critical_notes:
                       test_key = f"note_on_ch0_note{note}"
                       found = False
                       for action_id, mapping_data in self.midi_engine.midi_mappings.items():
                           if mapping_data.get('midi') == test_key:
                               action_type = mapping_data.get('type', 'unknown')
                               params = mapping_data.get('params', {})
                               preset = params.get('preset_name', 'N/A')
                               logging.info(f"   ‚úÖ Note {note}: {action_id} -> {action_type} ({preset})")
                               found = True
                               break
                       if not found:
                           logging.warning(f"   ‚ùå Note {note}: No mapping found")
                   
                   # 5. Test de referencias
                   logging.info("4. VERIFICANDO REFERENCIAS:")
                   logging.info(f"   mixer_window: {'‚úÖ' if self.midi_engine.mixer_window else '‚ùå'}")
                   logging.info(f"   control_panel: {'‚úÖ' if self.midi_engine.control_panel else '‚ùå'}")
                   
                   logging.info("=" * 80)
                   logging.info("üîß DEBUG FINALIZADO")
                   
               except Exception as e:
                   logging.error(f"Error en debug_midi_connection: {e}")
                   import traceback
                   traceback.print_exc()
       
    1:     def show_preferences(self):
               try:
                   dialog = PreferencesDialog(self.settings_manager, self.midi_engine, self.audio_analyzer, self)
                   dialog.exec()
               except Exception as e:
                   logging.error(f"Error opening preferences: {e}")
                   QMessageBox.critical(self, "Error", f"Could not open preferences: {str(e)}")
       
    1:     def test_midi_mappings(self):
               """Test MIDI mappings"""
               try:
                   if self.midi_engine:
                       # Test a few key mappings
                       test_notes = [37, 50, 55]  # Wire Terrain A, Mix A‚ÜíB 5s, Wire Terrain B
                       for note in test_notes:
                           self.midi_engine.test_midi_mapping(note)
                           
                       QMessageBox.information(self, "MIDI Test", 
                                             f"Tested MIDI mappings for notes: {test_notes}\nCheck console for results.")
                   else:
                       QMessageBox.warning(self, "Error", "MIDI Engine not available")
               except Exception as e:
                   logging.error(f"Error testing MIDI mappings: {e}")
                   QMessageBox.critical(self, "Error", f"Error testing MIDI mappings: {str(e)}")
       
    1:     def print_midi_mappings(self):
               """Print current MIDI mappings"""
               try:
                   if self.midi_engine:
                       self.midi_engine.print_current_mappings()
                       QMessageBox.information(self, "MIDI Mappings", "Current MIDI mappings printed to console.")
                   else:
                       QMessageBox.warning(self, "Error", "MIDI Engine not available")
               except Exception as e:
                   logging.error(f"Error printing MIDI mappings: {e}")
       
    1:     def refresh_devices(self):
               """Refresh device information and update displays"""
               try:
                   self.update_midi_device_display()
                   self.update_audio_device_display()
                   logging.info("Device information refreshed")
               except Exception as e:
                   logging.error(f"Error refreshing devices: {e}")
       
    1:     def on_preset_loaded_on_deck(self, deck_id, preset_name):
               """Handle preset loading from MIDI to update the UI"""
    8:         try:
    8:             import time
    8:             current_time = time.strftime("%H:%M:%S")
                   
    8:             if deck_id == 'A':
    6:                 self.deck_a_status['active_preset'] = preset_name
    6:                 self.deck_a_status['last_activity'] = current_time
                       
    6:                 self.deck_a_preset_label.setText(f"Preset: {preset_name}")
    6:                 self.deck_a_activity_label.setText(f"√öltima actividad: {current_time}")
                           
    2:             elif deck_id == 'B':
    2:                 self.deck_b_status['active_preset'] = preset_name
    2:                 self.deck_b_status['last_activity'] = current_time
                       
    2:                 self.deck_b_preset_label.setText(f"Preset: {preset_name}")
    2:                 self.deck_b_activity_label.setText(f"√öltima actividad: {current_time}")
                   
    8:             logging.info(f"‚úÖ UI updated for deck {deck_id} to preset {preset_name}")
               except Exception as e:
                   logging.error(f"Error updating preset selector for deck {deck_id}: {e}")
       
    1:     def update_midi_device_display(self, device_name=None):
               """Update MIDI device display with enhanced visual feedback"""
   25:         try:
   25:             if device_name:
    2:                 self.midi_status_label.setText(f"MIDI: {device_name}")
    2:                 self.midi_status_label.setStyleSheet("color: #00ff00; font-weight: bold; padding: 5px;")
                   else:
                       # Check current MIDI status
   23:                 midi_connected = False
   23:                 device_info = "Not Connected"
                       
   23:                 if self.midi_engine:
   23:                     try:
   23:                         if hasattr(self.midi_engine, 'is_port_open') and self.midi_engine.is_port_open():
   21:                             device_info = "Connected"
   21:                             midi_connected = True
    2:                         elif hasattr(self.midi_engine, 'list_input_ports'):
    2:                             ports = self.midi_engine.list_input_ports()
    2:                             if ports:
    2:                                 device_info = f"Available ({len(ports)} devices)"
                           except Exception as e:
                               device_info = f"Error: {str(e)}"
                       
   23:                 self.midi_status_label.setText(f"MIDI: {device_info}")
   23:                 if midi_connected:
   21:                     self.midi_status_label.setStyleSheet("color: #00ff00; font-weight: bold; padding: 5px;")
                       else:
    2:                     self.midi_status_label.setStyleSheet("color: #ff6600; font-weight: bold; padding: 5px;")
                           
               except Exception as e:
                   logging.error(f"Error updating MIDI device display: {e}")
                   self.midi_status_label.setText("MIDI: Error")
                   self.midi_status_label.setStyleSheet("color: red; font-weight: bold; padding: 5px;")
       
    1:     def update_audio_device_display(self):
               """Update audio device display"""
   22:         try:
                   # This is for future implementation if needed
   22:             pass
               except Exception as e:
                   logging.error(f"Error updating audio device display: {e}")
       
    1:     def update_audio_level(self, level):
               """Update audio level display"""
 2046:         try:
 2046:             self.audio_level_bar.setValue(int(max(0, min(100, level))))
               except Exception as e:
                   logging.error(f"Error updating audio level: {e}")
       
    1:     def update_frequency_bands(self, fft_data):
               """Update frequency band displays"""
 2046:         try:
                   # This would require frequency band bars to be implemented
 2046:             pass
               except Exception as e:
                   logging.error(f"Error updating frequency bands: {e}")
       
    1:     def update_info(self):
               """Update system information"""
  601:         try:
                   # Update mix value from mixer window
  601:             if self.mixer_window and hasattr(self.mixer_window, 'get_mix_value_percent'):
  601:                 mix_value = self.mixer_window.get_mix_value_percent()
  601:                 self.mix_value_label.setText(f"Crossfader: {mix_value}%")
  601:                 self.mix_progress_bar.setValue(mix_value)
                   
                   # Update device displays periodically
  601:             import time
  601:             current_time = time.time()
  601:             if not hasattr(self, 'last_device_update'):
    1:                 self.last_device_update = 0
                       
  601:             if current_time - self.last_device_update > 3.0:  # Every 3 seconds
   22:                 self.update_midi_device_display()
   22:                 self.update_audio_device_display()
   22:                 self.last_device_update = current_time
       
               except Exception as e:
                   logging.error(f"Error in update_info: {e}")
       
    1:     def on_midi_device_connected(self, device_name):
               """Handle MIDI device connection"""
    1:         try:
    1:             self.update_midi_device_display(device_name)
    1:             logging.info(f"üéπ MIDI device connected: {device_name}")
               except Exception as e:
                   logging.error(f"Error handling MIDI device connection: {e}")
       
    1:     def on_midi_device_disconnected(self, device_name):
               """Handle MIDI device disconnection"""
               try:
                   self.update_midi_device_display(None)
                   logging.info(f"üéπ MIDI device disconnected: {device_name}")
               except Exception as e:
                   logging.error(f"Error handling MIDI device disconnection: {e}")
       
    1:     def on_midi_activity(self, msg):
               """Handle raw MIDI activity and update activity tables"""
   14:         try:
   14:             self.turn_on_midi_led()
       
   14:             from datetime import datetime
   14:             timestamp = datetime.now().strftime("%H:%M:%S.%f")[:-3]
       
   14:             msg_type = getattr(msg, 'type', 'unknown')
   14:             data_str = str(msg)
   14:             midi_key = None
   14:             note = control = value = velocity = None
       
   14:             if msg_type == 'note_on':
   14:                 note = getattr(msg, 'note', 0)
   14:                 velocity = getattr(msg, 'velocity', 0)
   14:                 data_str = f"Note {note} Vel {velocity}"
   14:                 midi_key = f"note_on_ch{msg.channel}_note{note}"
                   elif msg_type == 'note_off':
                       note = getattr(msg, 'note', 0)
                       data_str = f"Note {note} off"
                       midi_key = f"note_off_ch{msg.channel}_note{note}"
                   elif msg_type == 'control_change':
                       control = getattr(msg, 'control', 0)
                       value = getattr(msg, 'value', 0)
                       data_str = f"CC {control} Val {value}"
                       midi_key = f"cc_ch{msg.channel}_control{control}"
       
   14:             deck_id = None
   14:             if midi_key and self.midi_engine:
   14:                 mappings = self.midi_engine.get_midi_mappings()
  228:                 for mapping_data in mappings.values():
  228:                     if mapping_data.get('midi') == midi_key:
   14:                         deck_id = mapping_data.get('params', {}).get('deck_id')
   14:                         break
       
   14:             if hasattr(self, 'midi_activity_table') and not getattr(self, 'midi_monitoring_paused', False):
   14:                 row = self.midi_activity_table.rowCount()
   14:                 self.midi_activity_table.insertRow(row)
   14:                 self.midi_activity_table.setItem(row, 0, QTableWidgetItem(timestamp))
   14:                 self.midi_activity_table.setItem(row, 1, QTableWidgetItem(msg_type))
   14:                 self.midi_activity_table.setItem(row, 2, QTableWidgetItem(data_str))
   14:                 self.midi_activity_table.setItem(row, 3, QTableWidgetItem(deck_id or '--'))
   14:                 self.midi_activity_table.scrollToBottom()
       
   14:             if deck_id == 'A':
    7:                 if hasattr(self, 'deck_a_activity_table'):
    7:                     self._add_row_to_table(self.deck_a_activity_table, timestamp, msg_type, data_str)
    7:                 if hasattr(self, 'deck_a_activity_label'):
    7:                     self.deck_a_activity_label.setText(f"√öltima actividad: {timestamp}")
    7:                 if msg_type == 'control_change' and hasattr(self, 'deck_a_controls_label'):
                           self.deck_a_controls_label.setText(f"CC {control}={value}")
    7:             elif deck_id == 'B':
    2:                 if hasattr(self, 'deck_b_activity_table'):
    2:                     self._add_row_to_table(self.deck_b_activity_table, timestamp, msg_type, data_str)
    2:                 if hasattr(self, 'deck_b_activity_label'):
    2:                     self.deck_b_activity_label.setText(f"√öltima actividad: {timestamp}")
    2:                 if msg_type == 'control_change' and hasattr(self, 'deck_b_controls_label'):
                           self.deck_b_controls_label.setText(f"CC {control}={value}")
       
               except Exception as e:
                   logging.error(f"‚ùå ERROR EN on_midi_activity: {e}")
                   import traceback
                   traceback.print_exc()
       
    1:     def on_note_activity(self, note, velocity):
               """Handle note activity"""
   14:         try:
   14:             import time
   14:             timestamp = time.strftime("%H:%M:%S")
   14:             note_names = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']
   14:             octave = note // 12 - 1
   14:             note_name = note_names[note % 12]
   14:             logging.debug(f"üéµ [{timestamp}] Note: {note_name}{octave} Vel:{velocity}")
               except Exception as e:
                   logging.error(f"Error handling note activity: {e}")
       
    1:     def on_cc_activity(self, control_id, value):
               """Handle CC activity"""
               try:
                   import time
                   timestamp = time.strftime("%H:%M:%S")
                   logging.debug(f"üéõÔ∏è [{timestamp}] CC: {control_id} = {value}")
               except Exception as e:
                   logging.error(f"Error handling CC activity: {e}")
       
    1:     def update_mappings_info(self):
               """Actualizar informaci√≥n de mappings"""
               try:
                   if self.midi_engine:
                       count = len(self.midi_engine.get_midi_mappings())
                       self.footer_mappings_info.setText(f"MIDI Mappings: {count}")
                   else:
                       self.footer_mappings_info.setText("MIDI Mappings: 0")
               except Exception as e:
                   logging.error(f"Error updating mappings info: {e}")
       
    1:     def cleanup(self):
               """Clean up resources"""
    2:         try:
                   # Stop timer
    2:             if hasattr(self, 'update_timer'):
    2:                 self.update_timer.stop()
                   
    2:             logging.debug("‚úÖ Control panel cleaned up")
                   
               except Exception as e:
                   logging.error(f"Error cleaning up control panel: {e}")
       
    1:     def closeEvent(self, event):
               """Handle close event"""
    1:         try:
    1:             self.cleanup()
    1:             super().closeEvent(event)
               except Exception as e:
                   logging.error(f"Error in closeEvent: {e}")
                   super().closeEvent(event)
