       # ui/main_application.py
    1: import sys
    1: import logging
    1: from PyQt6.QtWidgets import QApplication, QMessageBox
    1: from PyQt6.QtGui import QSurfaceFormat
    1: from PyQt6.QtCore import QTimer
       
    1: from utils.settings_manager import SettingsManager
    1: from midi.midi_engine import MidiEngine
    1: from visuals.visualizer_manager import VisualizerManager
    1: from audio.audio_analyzer import AudioAnalyzer
    1: from .mixer_window import MixerWindow
    1: from .control_panel_window import ControlPanelWindow
       
       # Force reload of visualizer_manager to ensure fresh loading
    1: import importlib
    1: import visuals.visualizer_manager
    1: importlib.reload(visuals.visualizer_manager)
    1: from visuals.visualizer_manager import VisualizerManager
       
       # Configure logging with better formatting
    2: logging.basicConfig(
    1:     level=logging.DEBUG,
    1:     format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    1:     handlers=[
    1:         logging.StreamHandler(sys.stdout),
    1:         logging.FileHandler('audiovisualizer.log', mode='w')
           ]
       )
       
       # Get specific loggers and set their levels to DEBUG
    1: logging.getLogger('visuals.deck').setLevel(logging.DEBUG)
    1: logging.getLogger('ui.mixer_window').setLevel(logging.DEBUG)
    1: logging.getLogger('visuals.visualizer_manager').setLevel(logging.DEBUG)
       
    2: class MainApplication:
    1:     def __init__(self):
    1:         logging.info("üöÄ Initializing Audio Visualizer Pro...")
               
    1:         try:
    1:             self.app = QApplication(sys.argv)
    1:             self.app.setApplicationName("Audio Visualizer Pro")
    1:             self.app.setApplicationVersion("1.0")
                   
                   # Set up OpenGL format for better compatibility
    1:             self.setup_opengl_format()
                   
                   # Initialize core components
    1:             self.initialize_components()
                   
                   # Validate components
    1:             self.validate_initialization()
                   
                   # Create UI windows with proper sequencing
    1:             self.create_windows()
                   
                   # CRITICAL: Setup connections and references BEFORE auto-connect
    1:             self.setup_connections()
                   
                   # Setup debug connections for MIDI
    1:             self.setup_debug_connections()
                   
    1:             logging.info("‚úÖ Audio Visualizer Pro initialized successfully!")
                   
               except Exception as e:
                   logging.critical(f"‚ùå Failed to initialize application: {e}")
                   import traceback
                   traceback.print_exc()
                   self.show_critical_error("Initialization Error", str(e))
                   sys.exit(1)
       
    1:     def setup_opengl_format(self):
               """Setup OpenGL surface format with better compatibility"""
    1:         try:
    1:             format = QSurfaceFormat()
    1:             format.setVersion(3, 3)
    1:             format.setProfile(QSurfaceFormat.OpenGLContextProfile.CoreProfile)
    1:             format.setDepthBufferSize(24)
    1:             format.setStencilBufferSize(8)
    1:             format.setSwapBehavior(QSurfaceFormat.SwapBehavior.DoubleBuffer)
    1:             format.setSamples(4)  # Anti-aliasing
    1:             QSurfaceFormat.setDefaultFormat(format)
    1:             logging.debug("‚úÖ OpenGL format configured")
               except Exception as e:
                   logging.error(f"‚ùå Error setting up OpenGL format: {e}")
                   raise
       
    1:     def initialize_components(self):
               """Initialize all core components"""
    1:         try:
                   # Initialize settings manager first
    1:             logging.info("üìã Initializing Settings Manager...")
    1:             self.settings_manager = SettingsManager()
                   
                   # Initialize visualizer manager
    1:             logging.info("üé® Initializing Visualizer Manager...")
    1:             self.visualizer_manager = VisualizerManager()
                   
                   # Initialize MIDI engine
    1:             logging.info("üéπ Initializing MIDI Engine...")
    1:             self.midi_engine = MidiEngine(self.settings_manager, self.visualizer_manager)
                   
                   # Initialize audio analyzer
    1:             logging.info("üéµ Initializing Audio Analyzer...")
    1:             self.audio_analyzer = AudioAnalyzer()
                   
    1:             logging.info("‚úÖ Core components initialized")
                   
               except Exception as e:
                   logging.error(f"‚ùå Error initializing components: {e}")
                   raise
       
    1:     def validate_initialization(self):
               """Validate that all components initialized correctly"""
    1:         try:
                   # Check visualizers
    1:             visualizer_names = self.visualizer_manager.get_visualizer_names()
    1:             if not visualizer_names:
                       raise Exception("No visualizers found! Check your visuals directory.")
                   
    1:             logging.info(f"üé® Loaded {len(visualizer_names)} visualizers: {visualizer_names}")
                   
                   # Check MIDI mappings
    1:             midi_mappings = self.midi_engine.get_midi_mappings()
    1:             logging.info(f"üéπ Loaded {len(midi_mappings)} MIDI mappings")
                   
                   # Check settings
    1:             settings = self.settings_manager.get_all_settings()
    1:             logging.info(f"üìã Loaded settings with {len(settings)} entries")
                   
               except Exception as e:
                   logging.error(f"‚ùå Validation failed: {e}")
                   raise
       
    1:     def create_windows(self):
               """Create and setup UI windows"""
    1:         try:
    1:             logging.info("üñ•Ô∏è Creating UI windows...")
                   
                   # Create mixer window first
    1:             self.mixer_window = MixerWindow(self.visualizer_manager)
    1:             logging.info("‚úÖ Mixer window created")
                   
                   # Create control panel (redise√±ado para operaci√≥n MIDI)
    2:             self.control_panel = ControlPanelWindow(
    1:                 self.mixer_window,
    1:                 self.settings_manager,
    1:                 self.midi_engine,
    1:                 self.visualizer_manager,
    1:                 self.audio_analyzer,
                   )
    1:             logging.info("‚úÖ Control panel created")
                   
               except Exception as e:
                   logging.error(f"‚ùå Error creating windows: {e}")
                   raise
       
    1:     def setup_connections(self):
               """Setup all signal connections and references - CRITICAL ORDER"""
    1:         try:
    1:             logging.info("üîó Setting up connections and references...")
                   
                   # STEP 1: Set application references in MIDI engine FIRST
    1:             logging.info("üîó Setting MIDI engine references...")
    2:             self.midi_engine.set_application_references(
    1:                 mixer_window=self.mixer_window,
    1:                 control_panel=self.control_panel
                   )
                   
                   # STEP 2: Connect MIDI signals to control panel for UI updates
    1:             logging.info("üîó Connecting MIDI signals...")
    1:             if hasattr(self.midi_engine, 'device_connected'):
    1:                 self.midi_engine.device_connected.connect(self.on_midi_device_connected)
    1:             if hasattr(self.midi_engine, 'device_disconnected'):
    1:                 self.midi_engine.device_disconnected.connect(self.on_midi_device_disconnected)
    1:             if hasattr(self.midi_engine, 'bpm_changed'):
    1:                 self.midi_engine.bpm_changed.connect(self.on_bpm_changed)
                   
                   # STEP 3: Verify references are set
    1:             if not self.midi_engine.mixer_window:
                       logging.error("‚ùå CRITICAL: mixer_window reference not set in MIDI engine!")
                       raise Exception("MIDI engine mixer_window reference failed")
                   
    1:             if not self.midi_engine.control_panel:
                       logging.error("‚ùå CRITICAL: control_panel reference not set in MIDI engine!")
                       raise Exception("MIDI engine control_panel reference failed")
                   
    1:             logging.info("‚úÖ All connections and references established")
                   
               except Exception as e:
                   logging.error(f"‚ùå Error setting up connections: {e}")
                   raise
       
    1:     def setup_debug_connections(self):
               """Setup debug connections for MIDI monitoring"""
    1:         try:
                   # Connect to MIDI learning signal for debugging
    1:             if hasattr(self.midi_engine, 'midi_message_received_for_learning'):
    1:                 self.midi_engine.midi_message_received_for_learning.connect(self.debug_midi_message)
                   
                   # Connect to raw MIDI messages for activity monitoring
    1:             if hasattr(self.midi_engine, 'midi_message_received'):
    1:                 self.midi_engine.midi_message_received.connect(self.debug_raw_midi_message)
                   
    1:             logging.info("üõ† Debug connections established")
                   
               except Exception as e:
                   logging.warning(f"‚ö†Ô∏è Could not setup debug connections: {e}")
       
    1:     def debug_midi_message(self, message_key):
               """Debug method to log all MIDI messages and check mappings"""
   14:         try:
   14:             logging.debug(f"üéπ MIDI Learning Signal: {message_key}")
                   
                   # Check if this message has a mapping
   14:             mappings_found = 0
  658:             for action_id, mapping_data in self.midi_engine.midi_mappings.items():
  644:                 if mapping_data.get('midi') == message_key:
   14:                     action_type = mapping_data.get('type', 'unknown')
   14:                     params = mapping_data.get('params', {})
   14:                     logging.debug(f"üéØ Found mapping: {action_id} -> {action_type} {params}")
   14:                     mappings_found += 1
                   
   14:             if mappings_found == 0:
                       logging.debug(f"üîç No mapping found for: {message_key}")
                   else:
   14:                 logging.debug(f"‚úÖ Found {mappings_found} mapping(s) for: {message_key}")
                       
               except Exception as e:
                   logging.error(f"Error in debug_midi_message: {e}")
       
    1:     def debug_raw_midi_message(self, msg):
               """Debug raw MIDI messages"""
   14:         try:
   14:             if hasattr(msg, 'type'):
   14:                 if msg.type in ['note_on', 'note_off', 'control_change']:
   14:                     logging.debug(f"üéº Raw MIDI: {msg.type} - {msg}")
               except Exception as e:
                   logging.error(f"Error in debug_raw_midi_message: {e}")
       
    1:     def on_midi_device_connected(self, device_name):
               """Handle MIDI device connection"""
    1:         try:
    1:             if hasattr(self, 'control_panel'):
    1:                 self.control_panel.update_midi_device_display(device_name)
    1:             logging.info(f"üéπ MIDI device connected: {device_name}")
                       
               except Exception as e:
                   logging.error(f"Error handling MIDI device connection: {e}")
       
    1:     def on_midi_device_disconnected(self, device_name):
               """Handle MIDI device disconnection"""
    1:         try:
    1:             if hasattr(self, 'control_panel'):
    1:                 self.control_panel.update_midi_device_display(None)
    1:             logging.info(f"üéπ MIDI device disconnected: {device_name}")
               except Exception as e:
                   logging.error(f"Error handling MIDI device disconnection: {e}")
       
    1:     def on_bpm_changed(self, bpm):
               """Handle BPM change"""
    1:         try:
    1:             if hasattr(self, 'control_panel'):
                       # Update BPM display if control panel has this method
    1:                 if hasattr(self.control_panel, 'update_bpm_display'):
                           self.control_panel.update_bpm_display(bpm)
    1:             logging.debug(f"ü•Å BPM updated: {bpm:.1f}")
               except Exception as e:
                   logging.error(f"Error handling BPM change: {e}")
       
    1:     def auto_connect_devices(self):
               """Auto-connect previously saved devices"""
    1:         try:
    1:             logging.info("üîå Auto-connecting saved devices...")
                   
                   # Auto-connect MIDI device
    1:             last_midi_device = self.settings_manager.get_setting("last_midi_device", "")
    1:             if last_midi_device:
    1:                 available_midi = self.midi_engine.list_input_ports()
    1:                 logging.debug(f"Available MIDI devices: {available_midi}")
                       
    1:                 if last_midi_device in available_midi:
    1:                     if self.midi_engine.open_input_port(last_midi_device):
    1:                         logging.info(f"‚úÖ Auto-connected to MIDI device: {last_midi_device}")
                           else:
                               logging.warning(f"‚ö†Ô∏è Failed to auto-connect to MIDI device: {last_midi_device}")
                       else:
                           logging.info(f"‚ùå Previously used MIDI device '{last_midi_device}' not available")
                   else:
                       logging.info("‚ÑπÔ∏è No MIDI device saved for auto-connection")
                   
                   # Auto-connect audio device
    1:             last_audio_device = self.settings_manager.get_setting("audio_settings.input_device", "")
    1:             if last_audio_device:
    1:                 try:
    1:                     available_audio = self.audio_analyzer.get_available_devices()
    1:                     logging.debug(f"Available audio devices: {len(available_audio)} devices")
                           
    3:                     for device in available_audio:
    3:                         device_text = f"{device['name']} ({device['channels']} ch)"
    3:                         if device_text == last_audio_device:
    1:                             self.audio_analyzer.set_input_device(device['index'])
    1:                             self.audio_analyzer.start_analysis()
    1:                             logging.info(f"‚úÖ Auto-connected to audio device: {last_audio_device}")
    1:                             break
                           else:
                               logging.info(f"‚ùå Previously used audio device '{last_audio_device}' not available")
                       except Exception as e:
                           logging.warning(f"‚ö†Ô∏è Error auto-connecting audio device: {e}")
                   else:
                       logging.info("‚ÑπÔ∏è No audio device saved for auto-connection")
                       
               except Exception as e:
                   logging.error(f"Error in auto_connect_devices: {e}")
       
    1:     def show_critical_error(self, title, message):
               """Show critical error dialog"""
               try:
                   app = QApplication.instance()
                   if app:
                       QMessageBox.critical(None, title, message)
               except:
                   print(f"CRITICAL ERROR: {title} - {message}")
       
    1:     def show_windows(self):
               """Show both windows with proper positioning"""
    1:         try:
    1:             logging.info("üñ•Ô∏è Showing application windows...")
                   
                   # Show mixer window first
    1:             self.mixer_window.show()
                   
                   # Show control panel
    1:             self.control_panel.show()
                   
                   # Apply saved window positions
    1:             QTimer.singleShot(200, self.apply_window_positions)
                   
                   # IMPORTANT: Auto-connect devices AFTER windows are shown and connections established
    1:             QTimer.singleShot(1000, self.auto_connect_devices)
                   
    1:             logging.info("‚úÖ Windows displayed")
                   
               except Exception as e:
                   logging.error(f"Error showing windows: {e}")
                   raise
       
    1:     def apply_window_positions(self):
               """Apply saved window positions"""
    1:         try:
                   # Get saved positions
    1:             cp_position = self.settings_manager.get_window_position("control_panel")
    1:             mixer_position = self.settings_manager.get_window_position("main_window")
                   
                   # Apply control panel position
    1:             if cp_position and hasattr(self, 'control_panel'):
    2:                 self.control_panel.setGeometry(
    1:                     cp_position.get('x', 50),
    1:                     cp_position.get('y', 50),
    1:                     cp_position.get('width', 1600),
    1:                     cp_position.get('height', 900)
                       )
                   
                   # Apply mixer window position
    1:             if mixer_position:
    2:                 self.mixer_window.setGeometry(
    1:                     mixer_position.get('x', 100),
    1:                     mixer_position.get('y', 100),
    1:                     mixer_position.get('width', 800),
    1:                     mixer_position.get('height', 600)
                       )
                       
    1:             logging.debug("‚úÖ Window positions applied")
                   
               except Exception as e:
                   logging.error(f"Error applying window positions: {e}")
       
    1:     def save_window_positions(self):
               """Save current window positions"""
    1:         try:
                   # Save control panel position
    1:             if hasattr(self, 'control_panel'):
    1:                 cp_geometry = self.control_panel.geometry()
    2:                 self.settings_manager.set_window_position(
    1:                     "control_panel",
    1:                     cp_geometry.x(),
    1:                     cp_geometry.y(), 
    1:                     cp_geometry.width(),
    1:                     cp_geometry.height()
                       )
                   
                   # Save mixer window position
    1:             mixer_geometry = self.mixer_window.geometry()
    2:             self.settings_manager.set_window_position(
    1:                 "main_window",
    1:                 mixer_geometry.x(),
    1:                 mixer_geometry.y(),
    1:                 mixer_geometry.width(), 
    1:                 mixer_geometry.height()
                   )
                   
    1:             logging.debug("‚úÖ Window positions saved")
                   
               except Exception as e:
                   logging.error(f"Error saving window positions: {e}")
       
    1:     def cleanup(self):
               """Cleanup application resources"""
    1:         try:
    1:             logging.info("üßπ Cleaning up application resources...")
                   
                   # Save window positions
    1:             self.save_window_positions()
                   
                   # Close MIDI connection
    1:             if hasattr(self, 'midi_engine') and self.midi_engine:
    1:                 self.midi_engine.close_input_port()
    1:                 logging.debug("‚úÖ MIDI connection closed")
                   
                   # Stop audio analysis
    1:             if hasattr(self, 'audio_analyzer') and self.audio_analyzer:
    1:                 self.audio_analyzer.stop_analysis()
    1:                 logging.debug("‚úÖ Audio analysis stopped")
                   
                   # Cleanup mixer window OpenGL resources
    1:             if hasattr(self, 'mixer_window') and self.mixer_window:
    1:                 self.mixer_window.cleanup()
    1:                 logging.debug("‚úÖ OpenGL resources cleaned")
                   
                   # Cleanup control panel
    1:             if hasattr(self, 'control_panel') and self.control_panel:
    1:                 self.control_panel.cleanup()
    1:                 logging.debug("‚úÖ Control panel cleaned")
                   
    1:             logging.info("‚úÖ Cleanup completed")
                   
               except Exception as e:
                   logging.error(f"Error during cleanup: {e}")
       
    1:     def run(self):
               """Run the application"""
    1:         try:
    1:             logging.info("üöÄ Starting Audio Visualizer Pro...")
                   
                   # Show windows
    1:             self.show_windows()
                   
                   # Run the application
    1:             result = self.app.exec()
                   
    1:             logging.info(f"üì± Application finished with exit code: {result}")
    1:             return result
                   
               except Exception as e:
                   logging.error(f"Error running application: {e}")
                   return 1
               finally:
                   # Always cleanup
    1:             self.cleanup()
