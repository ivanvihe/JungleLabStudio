       # visuals/deck.py
    1: import logging
    1: import time
    1: import math
    1: import os
    1: from PyQt6.QtOpenGL import QOpenGLFramebufferObject, QOpenGLFramebufferObjectFormat
    1: from PyQt6.QtCore import QSize, QMutex, QMutexLocker
    1: from PyQt6.QtGui import QOpenGLContext
    1: from OpenGL.GL import *
    1: from .render_backend import GLBackend, ModernGLBackend
       
    2: class Deck:
    1:     def __init__(self, visualizer_manager, deck_id="", use_moderngl=False, use_post=False):
    2:         self.visualizer_manager = visualizer_manager
    2:         self.deck_id = deck_id  # For debugging
    2:         self.current_visualizer = None  # Renamed for clarity
    2:         self.fbo = None
    2:         self.current_visualizer_name = None  # Renamed for clarity
    2:         self.size = QSize(800, 600)
               
               # State tracking
    2:         self._gl_initialized = False
    2:         self._frame_count = 0
    2:         self._last_error_log = 0
               
               # Thread safety
    2:         self._mutex = QMutex()
               
               # Render state
    2:         self._last_render_time = 0
    2:         self._render_interval = 1.0 / 60.0  # 60 FPS limit
               
               # Track if FBO has been rendered to
    2:         self._fbo_dirty = True
               
               # Controls cache
    2:         self.controls = {}
       
    2:         use_moderngl = use_moderngl or os.getenv("USE_MODERNGL") == "1"
    2:         self.backend = ModernGLBackend() if use_moderngl else GLBackend()
    2:         self.use_post = use_post
       
    2:         logging.debug(f"üéÆ Deck {deck_id} initialized with size {self.size.width()}x{self.size.height()}")
       
    1:     def ensure_fbo(self):
               """Ensure we have a valid FBO"""
 3136:         if not self.fbo or not self.fbo.isValid():
                   self._recreate_fbo()
 3136:         return self.fbo and self.fbo.isValid()
       
    1:     def set_visualizer(self, visualizer_name):
               """Set a new visualizer for this deck"""
   16:         with QMutexLocker(self._mutex):
    8:             logging.info(f"üé® Deck {self.deck_id}: Setting visualizer to {visualizer_name}")
                   
                   # Clean up old visualizer first
    8:             self._cleanup_current_visualizer()
                   
                   # Set new visualizer
    8:             self.current_visualizer_name = visualizer_name
    8:             visualizer_class = self.visualizer_manager.get_visualizer_class(visualizer_name)
                   
    8:             if visualizer_class:
    8:                 try:
                           # Create visualizer instance
    8:                     self.current_visualizer = visualizer_class()
    8:                     self._gl_initialized = False
    8:                     self._fbo_dirty = True
                           
                           # Update controls cache
    8:                     self._update_controls_cache()
                           
    8:                     logging.info(f"‚úÖ Deck {self.deck_id}: Created visualizer instance: {visualizer_name}")
                           
                       except Exception as e:
                           logging.error(f"‚ùå Deck {self.deck_id}: Error creating visualizer {visualizer_name}: {e}")
                           import traceback
                           traceback.print_exc()
                           self.current_visualizer = None
                           self.controls = {}
                   else:
                       logging.error(f"‚ùå Deck {self.deck_id}: Visualizer class not found: {visualizer_name}")
       
    1:     def clear_visualizer(self):
               """Clear the current visualizer and show nothing (black)"""
               with QMutexLocker(self._mutex):
                   try:
                       logging.info(f"üö´ Clearing visualizer for deck {self.deck_id}")
                       
                       # Cleanup current visualizer
                       self._cleanup_current_visualizer()
                       
                       # Clear all references
                       self.current_visualizer = None
                       self.current_visualizer_name = None
                       self.controls = {}
                       self._gl_initialized = False
                       self._fbo_dirty = True
                       
                       logging.info(f"‚úÖ Deck {self.deck_id} visualizer cleared")
                       
                   except Exception as e:
                       logging.error(f"‚ùå Error clearing visualizer for deck {self.deck_id}: {e}")
       
    1:     def has_active_visualizer(self):
               """Check if deck has an active visualizer"""
 9580:         with QMutexLocker(self._mutex):
 4790:             return self.current_visualizer is not None
       
    1:     def _cleanup_current_visualizer(self):
               """Clean up current visualizer"""
   12:         if self.current_visualizer:
    8:             logging.debug(f"üßπ Deck {self.deck_id}: Cleaning up visualizer: {self.current_visualizer_name}")
    8:             try:
    8:                 if hasattr(self.current_visualizer, 'cleanup'):
    8:                     self.current_visualizer.cleanup()
                   except Exception as e:
                       logging.error(f"‚ùå Deck {self.deck_id}: Error cleaning up visualizer: {e}")
                   
    8:             self.current_visualizer = None
    8:             self._gl_initialized = False
       
    1:     def _update_controls_cache(self):
               """Update the controls cache from current visualizer"""
   16:         try:
   16:             if self.current_visualizer and hasattr(self.current_visualizer, 'get_controls'):
   16:                 self.controls = self.current_visualizer.get_controls() or {}
   16:                 logging.debug(f"üéõÔ∏è Deck {self.deck_id}: Cached {len(self.controls)} controls")
                   else:
                       self.controls = {}
               except Exception as e:
                   logging.error(f"‚ùå Deck {self.deck_id}: Error updating controls cache: {e}")
                   self.controls = {}
       
    1:     def _initialize_visualizer_in_fbo(self):
               """Initialize the visualizer within the FBO context"""
    8:         if not self.current_visualizer:
                   return False
                   
    8:         try:
    8:             logging.debug(f"üîß Deck {self.deck_id}: Initializing visualizer {self.current_visualizer_name} in FBO")
                   
                   # Clear any existing GL errors
    8:             while glGetError() != GL_NO_ERROR:
                       pass
       
                   # Set viewport for FBO
    8:             self.backend.set_viewport(0, 0, self.size.width(), self.size.height())
       
                   # Initialize visualizer
    8:             if hasattr(self.current_visualizer, 'initializeGL'):
    8:                 try:
    8:                     self.current_visualizer.initializeGL(self.backend)
    7:                 except TypeError:
    7:                     self.current_visualizer.initializeGL()
       
                   # Resize visualizer
    8:             if hasattr(self.current_visualizer, 'resizeGL'):
    8:                 try:
   16:                     self.current_visualizer.resizeGL(
    8:                         self.size.width(), self.size.height(), self.backend
                           )
    7:                 except TypeError:
   14:                     self.current_visualizer.resizeGL(
    7:                         self.size.width(), self.size.height()
                           )
                   
    8:             self._gl_initialized = True
                   
                   # Update controls after initialization
    8:             self._update_controls_cache()
                   
    8:             logging.info(f"‚úÖ Deck {self.deck_id}: Visualizer {self.current_visualizer_name} initialized")
    8:             return True
                   
               except Exception as e:
                   logging.error(f"‚ùå Deck {self.deck_id}: Error initializing visualizer: {e}")
                   import traceback
                   traceback.print_exc()
                   return False
       
    1:     def render_to_fbo(self):
               """Render the visualizer to the FBO"""
 6272:         with QMutexLocker(self._mutex):
                   # Ensure we have an FBO
 3136:             if not self.ensure_fbo():
                       return False
                       
                   # Check if we have a valid context
 3136:             context = QOpenGLContext.currentContext()
 3136:             if not context:
                       logging.debug(f"Deck {self.deck_id}: No OpenGL context available")
                       return False
                       
 3136:             try:
 3136:                 self.backend.ensure_context()
       
                       # Save current FBO binding
 3136:                 previous_fbo = glGetIntegerv(GL_FRAMEBUFFER_BINDING)
       
                       # Bind our FBO
 3136:                 if not self.fbo.bind():
                           logging.error(f"‚ùå Deck {self.deck_id}: Failed to bind FBO")
                           return False
       
 3136:                 self.backend.begin_target((self.size.width(), self.size.height()))
       
                       # Clear the FBO
 3136:                 self.backend.clear(0.0, 0.0, 0.0, 1.0)
                       
 3136:                 if self.current_visualizer:
                           # Initialize if needed
 2505:                     if not self._gl_initialized:
    8:                         if not self._initialize_visualizer_in_fbo():
                                   self._render_fallback()
                                   self.fbo.release()
                                   # Restore previous FBO
                                   glBindFramebuffer(GL_FRAMEBUFFER, previous_fbo)
                                   return False
                           
                           # Render the visualizer
 2505:                     if hasattr(self.current_visualizer, 'paintGL'):
 2505:                         try:
                                   # Paint visualizer directly
 2505:                             try:
 5010:                                 self.current_visualizer.paintGL(
 2505:                                     time.time(),
 2505:                                     (self.size.width(), self.size.height()),
 2505:                                     self.backend,
                                       )
 1744:                             except TypeError:
 1744:                                 self.current_visualizer.paintGL()
       
 2505:                             self._frame_count += 1
 2505:                             if self._frame_count % 300 == 0:
    7:                                 logging.debug(f"üé¨ Deck {self.deck_id}: {self.current_visualizer_name} - Frame {self._frame_count}")
       
                               except Exception as e:
                                   current_time = time.time()
                                   if current_time - self._last_error_log > 5.0:
                                       logging.error(f"‚ùå Deck {self.deck_id}: Error in paintGL: {e}")
                                       self._last_error_log = current_time
                                   self._render_fallback()
                               finally:
                                   # Reset GL state changed by visualizers
 2505:                             try:
 2505:                                 glUseProgram(0)
 2505:                                 glDisable(GL_DEPTH_TEST)
 2505:                                 glDisable(GL_CULL_FACE)
 2505:                                 glDepthMask(GL_TRUE)
 2505:                                 glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)
                                   except Exception:
                                       pass
                       else:
                           # No visualizer - render black (already cleared above)
  631:                     pass
                       
 3136:                 if self.use_post and isinstance(self.backend, ModernGLBackend):
                           # TODO: implement post-processing effects (FXAA/Bloom)
                           pass
       
 3136:                 self.backend.end_target()
       
                       # Release our FBO
 3136:                 self.fbo.release()
       
                       # Restore previous FBO binding
 3136:                 glBindFramebuffer(GL_FRAMEBUFFER, previous_fbo)
                       
 3136:                 self._fbo_dirty = False
 3136:                 return True
                       
                   except Exception as e:
                       logging.error(f"‚ùå Deck {self.deck_id}: Error rendering to FBO: {e}")
                       if self.fbo and self.fbo.isBound():
                           self.fbo.release()
                       return False
       
    1:     def paint(self):
               """Main paint method - ensures FBO is rendered"""
               # Rate limiting
 4790:         current_time = time.time()
 4790:         if current_time - self._last_render_time < self._render_interval:
 1654:             return
 3136:         self._last_render_time = current_time
               
               # Render to FBO
 3136:         self.render_to_fbo()
       
    1:     def _render_fallback(self):
               """Render a fallback pattern when visualizer fails"""
               try:
                   # Static dark pattern for failed visualizers
                   if self.deck_id == "A":
                       self.backend.clear(0.1, 0.0, 0.0, 1.0)  # Dark red
                   else:
                       self.backend.clear(0.0, 0.0, 0.1, 1.0)  # Dark blue
               except Exception:
                   # Ultimate fallback - just black
                   try:
                       self.backend.clear(0.0, 0.0, 0.0, 1.0)
                   except Exception:
                       pass
       
    1:     def resize(self, size):
               """Resize the deck and recreate FBO if needed"""
   12:         with QMutexLocker(self._mutex):
    6:             if self.size == size:
    2:                 return
                       
    4:             logging.debug(f"üìê Deck {self.deck_id}: Resizing from {self.size.width()}x{self.size.height()} to {size.width()}x{size.height()}")
    4:             self.size = size
    4:             self._recreate_fbo()
                   
                   # Mark as needing re-initialization
    4:             if self.current_visualizer:
                       self._gl_initialized = False
                       self._fbo_dirty = True
       
    1:     def _recreate_fbo(self):
               """Recreate the framebuffer object with the current size"""
    4:         try:
                   # Check for valid context
    4:             context = QOpenGLContext.currentContext()
    4:             if not context:
                       logging.debug(f"Deck {self.deck_id}: No context for FBO creation")
                       return
                   
                   # Clean up old FBO
    4:             if self.fbo:
    2:                 if self.fbo.isBound():
                           self.fbo.release()
    2:                 del self.fbo
    2:                 self.fbo = None
                       
                   # Create new FBO only if size is valid
    4:             if self.size.width() > 0 and self.size.height() > 0:
                       # Create FBO format
    4:                 fbo_format = QOpenGLFramebufferObjectFormat()
    4:                 fbo_format.setAttachment(QOpenGLFramebufferObject.Attachment.CombinedDepthStencil)
    4:                 fbo_format.setSamples(0)  # No multisampling for performance
                       
                       # Create FBO
    4:                 self.fbo = QOpenGLFramebufferObject(self.size, fbo_format)
                       
    4:                 if not self.fbo.isValid():
                           logging.error(f"‚ùå Deck {self.deck_id}: Failed to create valid FBO")
                           self.fbo = None
                       else:
    4:                     logging.debug(f"‚úÖ Deck {self.deck_id}: Created FBO {self.size.width()}x{self.size.height()}, Texture: {self.fbo.texture()}")
    4:                     self._fbo_dirty = True
                           
               except Exception as e:
                   logging.error(f"‚ùå Deck {self.deck_id}: Error recreating FBO: {e}")
                   self.fbo = None
       
    1:     def get_texture(self):
               """Return the texture ID of the framebuffer"""
 7624:         with QMutexLocker(self._mutex):
                   # Make sure we have a valid FBO
 3812:             if not self.fbo or not self.fbo.isValid():
                       # Try to recreate the FBO when invalid ‚Äì this can happen
                       # when the context wasn't ready during initialization.
                       self._recreate_fbo()
                       self._gl_initialized = False
       
                   # Ensure the framebuffer has the latest rendering
 3812:             if self._fbo_dirty and self.fbo and self.fbo.isValid():
                       self.render_to_fbo()
       
 3812:             if self.fbo and self.fbo.isValid():
 3812:                 return self.fbo.texture()
                   return 0
       
    1:     def get_controls(self):
               """Get available controls from the current visualizer"""
               with QMutexLocker(self._mutex):
                   # Return cached controls for performance
                   if self.controls:
                       return self.controls.copy()
                   
                   # Fallback: get directly from visualizer if cache is empty
                   if self.current_visualizer and hasattr(self.current_visualizer, 'get_controls'):
                       try:
                           controls = self.current_visualizer.get_controls() or {}
                           self.controls = controls  # Update cache
                           return controls.copy()
                       except Exception as e:
                           logging.error(f"‚ùå Deck {self.deck_id}: Error getting controls: {e}")
                   
                   return {}
       
    1:     def update_control(self, name, value):
               """Update a control parameter on the current visualizer"""
               with QMutexLocker(self._mutex):
                   if self.current_visualizer and hasattr(self.current_visualizer, 'update_control'):
                       try:
                           self.current_visualizer.update_control(name, value)
                           self._fbo_dirty = True
                           
                           # Update cached control value
                           if name in self.controls:
                               self.controls[name]['value'] = value
                           
                           logging.debug(f"üéõÔ∏è Deck {self.deck_id}: Updated {name} = {value}")
                       except Exception as e:
                           logging.error(f"‚ùå Deck {self.deck_id}: Error updating control {name}: {e}")
       
    1:     def trigger_action(self, action_name):
               """Trigger a custom action on the current visualizer"""
               with QMutexLocker(self._mutex):
                   if self.current_visualizer and hasattr(self.current_visualizer, 'trigger_action'):
                       try:
                           self.current_visualizer.trigger_action(action_name)
                           self._fbo_dirty = True
                           logging.debug(f"üé¨ Deck {self.deck_id}: Triggered action {action_name}")
                       except Exception as e:
                           logging.error(f"‚ùå Deck {self.deck_id}: Error triggering action {action_name}: {e}")
       
    1:     def get_current_visualizer_name(self):
               """Get the name of the current visualizer"""
               with QMutexLocker(self._mutex):
                   return self.current_visualizer_name
       
    1:     def is_ready(self):
               """Check if deck is ready for rendering"""
               with QMutexLocker(self._mutex):
                   return self.fbo and self.fbo.isValid()
       
    1:     def get_deck_info(self):
               """Get comprehensive deck information"""
               with QMutexLocker(self._mutex):
                   return {
                       'deck_id': self.deck_id,
                       'has_visualizer': self.has_active_visualizer(),
                       'visualizer_name': self.current_visualizer_name,
                       'is_ready': self.is_ready(),
                       'fbo_size': f"{self.size.width()}x{self.size.height()}",
                       'frame_count': self._frame_count,
                       'controls_count': len(self.controls),
                       'gl_initialized': self._gl_initialized
                   }
       
    1:     def force_refresh(self):
               """Force refresh of the visualizer (useful for parameter changes)"""
               with QMutexLocker(self._mutex):
                   self._fbo_dirty = True
                   if self.current_visualizer:
                       # Update controls cache
                       self._update_controls_cache()
       
    1:     def cleanup(self):
               """Clean up resources"""
    8:         with QMutexLocker(self._mutex):
    4:             logging.debug(f"üßπ Deck {self.deck_id}: Cleaning up")
                   
                   # Clean up visualizer
    4:             self._cleanup_current_visualizer()
                   
                   # Clean up FBO
    4:             if self.fbo:
    2:                 if self.fbo.isBound():
                           self.fbo.release()
    2:                 del self.fbo
    2:                 self.fbo = None
                   
                   # Clear controls
    4:             self.controls = {}
       
    4:             logging.debug(f"‚úÖ Deck {self.deck_id}: Cleanup completed")
