       # TODO: migrate to RenderBackend (ModernGL)
       # visuals/presets/kaleido_tunney.py
    1: import os
    1: import logging
    1: import numpy as np
    1: import ctypes
    1: import time
    1: import math
    1: from OpenGL.GL import *
    1: from visuals.base_visualizer import BaseVisualizer
       
       # Import OpenGL safety functions
    1: try:
    1:     from opengl_fixes import OpenGLSafety
       except ImportError:
           class OpenGLSafety:
               @staticmethod
               def safe_line_width(width):
                   try:
                       glLineWidth(max(1.0, min(width, 10.0)))
                   except:
                       glLineWidth(1.0)
               
               @staticmethod
               def check_gl_errors(context=""):
                   pass
       
    2: class KaleidoTunnelVisualizer(BaseVisualizer):
    1:     visual_name = "Kaleido Tunnel"
           
    1:     def __init__(self, *args, **kwargs):
    1:         super().__init__(*args, **kwargs)
    1:         self.program = None
    1:         self.vao = None
    1:         self.vbo = None
    1:         self.ebo = None
    1:         self.start_time = time.time()
               
               # Parameters
    1:         self.rotation_speed = 50
    1:         self.tunnel_depth = 80
    1:         self.color_intensity = 100
    1:         self.pattern_complexity = 60
    1:         self.tunnel_radius = 3.0
    1:         self.segments_per_ring = 32
    1:         self.rings = 50
               
               # Geometry
    1:         self.vertices = None
    1:         self.indices = None
    1:         self.vertex_count = 0
       
    1:     def get_controls(self):
    2:         return {
    2:             "Rotation Speed": {"type": "slider", "min": 10, "max": 200, "value": self.rotation_speed},
    2:             "Tunnel Depth": {"type": "slider", "min": 20, "max": 150, "value": self.tunnel_depth},
    2:             "Color Intensity": {"type": "slider", "min": 30, "max": 200, "value": self.color_intensity},
    2:             "Pattern Complexity": {"type": "slider", "min": 20, "max": 120, "value": self.pattern_complexity},
    2:             "Tunnel Radius": {"type": "slider", "min": 50, "max": 200, "value": int(self.tunnel_radius * 50)}
               }
       
    1:     def update_control(self, name, value):
               if name == "Rotation Speed":
                   self.rotation_speed = value
               elif name == "Tunnel Depth":
                   self.tunnel_depth = value
                   self.generate_tunnel_geometry()
                   self.setup_buffers()
               elif name == "Color Intensity":
                   self.color_intensity = value
               elif name == "Pattern Complexity":
                   self.pattern_complexity = value
                   self.generate_tunnel_geometry()
                   self.setup_buffers()
               elif name == "Tunnel Radius":
                   self.tunnel_radius = float(value) / 50.0
                   self.generate_tunnel_geometry()
                   self.setup_buffers()
       
    1:     def load_shaders(self):
               """Load shaders with inline fallback"""
    1:         vs_src = """
               #version 330 core
               layout (location = 0) in vec3 aPos;
               layout (location = 1) in vec4 aColor;
               uniform mat4 model;
               uniform mat4 view;
               uniform mat4 projection;
               uniform float time;
               uniform float intensity;
               out vec4 vColor;
               
               void main()
               {
                   vec3 pos = aPos;
                   
                   // Add kaleidoscope wave effects
                   float wave1 = sin(time * 2.0 + pos.z * 0.5 + atan(pos.y, pos.x) * 6.0);
                   float wave2 = cos(time * 1.5 + pos.z * 0.3 + length(pos.xy) * 4.0);
                   
                   // Slight position displacement for hypnotic effect
                   pos.x += wave1 * 0.05 * intensity;
                   pos.y += wave2 * 0.05 * intensity;
                   
                   gl_Position = projection * view * model * vec4(pos, 1.0);
                   
                   // Color modulation based on waves
                   vec4 modColor = aColor;
                   modColor.rgb *= (0.8 + 0.2 * wave1) * (0.8 + 0.2 * wave2);
                   modColor.rgb *= intensity;
                   
                   vColor = modColor;
               }
               """
               
    1:         fs_src = """
               #version 330 core
               in vec4 vColor;
               out vec4 FragColor;
               
               void main()
               {
                   FragColor = vec4(vColor.rgb, 0.8);  // Semi-transparent for mixing
               }
               """
               
    1:         return self.compile_shader_program(vs_src, fs_src)
       
    1:     def compile_shader_program(self, vs_src, fs_src):
               """Compile shader program"""
    1:         try:
                   # Vertex shader
    1:             vs = glCreateShader(GL_VERTEX_SHADER)
    1:             glShaderSource(vs, vs_src)
    1:             glCompileShader(vs)
                   
    1:             if not glGetShaderiv(vs, GL_COMPILE_STATUS):
                       error = glGetShaderInfoLog(vs).decode()
                       logging.error(f"Vertex shader error: {error}")
                       return None
                   
                   # Fragment shader
    1:             fs = glCreateShader(GL_FRAGMENT_SHADER)
    1:             glShaderSource(fs, fs_src)
    1:             glCompileShader(fs)
                   
    1:             if not glGetShaderiv(fs, GL_COMPILE_STATUS):
                       error = glGetShaderInfoLog(fs).decode()
                       logging.error(f"Fragment shader error: {error}")
                       return None
                   
                   # Program
    1:             program = glCreateProgram()
    1:             glAttachShader(program, vs)
    1:             glAttachShader(program, fs)
    1:             glLinkProgram(program)
                   
    1:             if not glGetProgramiv(program, GL_LINK_STATUS):
                       error = glGetProgramInfoLog(program).decode()
                       logging.error(f"Shader program error: {error}")
                       return None
                   
    1:             glDeleteShader(vs)
    1:             glDeleteShader(fs)
                   
    1:             return program
                   
               except Exception as e:
                   logging.error(f"Error compiling shaders: {e}")
                   return None
       
    1:     def generate_tunnel_geometry(self):
               """Generate improved tunnel geometry with triangles"""
    1:         try:
                   # Adjusted parameters based on controls
    1:             self.segments_per_ring = max(12, int(self.pattern_complexity / 5))
    1:             self.rings = max(20, int(self.tunnel_depth / 2))
                   
    1:             vertices = []
    1:             indices = []
                   
                   # Generate tunnel rings
   41:             for ring in range(self.rings):
   40:                 z = -ring * 0.5  # Move backwards into the tunnel
                       
                       # Variable radius for interesting tunnel shape
   40:                 radius_variation = 1.0 + 0.3 * math.sin(ring * 0.2)
   40:                 current_radius = self.tunnel_radius * radius_variation
                       
  520:                 for seg in range(self.segments_per_ring):
  480:                     angle = (seg / self.segments_per_ring) * 2 * math.pi
                           
  480:                     x = current_radius * math.cos(angle)
  480:                     y = current_radius * math.sin(angle)
                           
                           # Kaleidoscope colors based on position and ring
  480:                     hue_base = (angle / (2 * math.pi)) + (ring * 0.1)
  480:                     r = 0.5 + 0.5 * math.sin(hue_base * 6.0)
  480:                     g = 0.5 + 0.5 * math.sin(hue_base * 6.0 + 2.0)
  480:                     b = 0.5 + 0.5 * math.sin(hue_base * 6.0 + 4.0)
                           
                           # Distance-based alpha fading
  480:                     alpha = 0.9 * (1.0 - ring / self.rings)
                           
  480:                     vertices.extend([x, y, z, r, g, b, alpha])
                   
                   # Generate indices for triangular mesh
   40:             for ring in range(self.rings - 1):
  507:                 for seg in range(self.segments_per_ring):
                           # Current ring vertices
  468:                     current = ring * self.segments_per_ring + seg
  468:                     next_seg = ring * self.segments_per_ring + ((seg + 1) % self.segments_per_ring)
                           
                           # Next ring vertices
  468:                     next_ring = (ring + 1) * self.segments_per_ring + seg
  468:                     next_ring_next_seg = (ring + 1) * self.segments_per_ring + ((seg + 1) % self.segments_per_ring)
                           
                           # Two triangles per quad
  468:                     indices.extend([current, next_ring, next_seg])
  468:                     indices.extend([next_seg, next_ring, next_ring_next_seg])
                   
    1:             self.vertices = np.array(vertices, dtype=np.float32)
    1:             self.indices = np.array(indices, dtype=np.uint32)
    1:             self.vertex_count = len(self.vertices) // 7
                   
    1:             print(f"Generated tunnel: {self.rings} rings x {self.segments_per_ring} segments = {self.vertex_count} vertices")
                   
               except Exception as e:
                   logging.error(f"Error generating tunnel geometry: {e}")
       
    1:     def setup_buffers(self):
               """Setup OpenGL buffers"""
    1:         try:
    1:             if self.vertices is None:
                       return
                   
                   # Cleanup old buffers
    1:             if self.vao:
                       glDeleteVertexArrays(1, [self.vao])
    1:             if self.vbo:
                       glDeleteBuffers(1, [self.vbo])
    1:             if self.ebo:
                       glDeleteBuffers(1, [self.ebo])
                   
                   # Create new buffers
    1:             self.vao = glGenVertexArrays(1)
    1:             self.vbo = glGenBuffers(1)
    1:             self.ebo = glGenBuffers(1)
                   
    1:             glBindVertexArray(self.vao)
                   
                   # Vertex buffer
    1:             glBindBuffer(GL_ARRAY_BUFFER, self.vbo)
    1:             glBufferData(GL_ARRAY_BUFFER, self.vertices.nbytes, self.vertices, GL_STATIC_DRAW)
                   
                   # Position attribute
    1:             glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 7 * 4, ctypes.c_void_p(0))
    1:             glEnableVertexAttribArray(0)
                   
                   # Color attribute
    1:             glVertexAttribPointer(1, 4, GL_FLOAT, GL_FALSE, 7 * 4, ctypes.c_void_p(3 * 4))
    1:             glEnableVertexAttribArray(1)
                   
                   # Index buffer
    1:             glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, self.ebo)
    1:             glBufferData(GL_ELEMENT_ARRAY_BUFFER, self.indices.nbytes, self.indices, GL_STATIC_DRAW)
                   
    1:             glBindVertexArray(0)
                   
               except Exception as e:
                   logging.error(f"Error setting up buffers: {e}")
       
    1:     def initializeGL(self):
               """Initialize OpenGL state"""
    1:         logging.info("KaleidoTunnel: Initializing...")
               
               # TRANSPARENT BACKGROUND FOR MIXING
    1:         glClearColor(0.0, 0.0, 0.0, 0.0)
    1:         glEnable(GL_BLEND)
    1:         glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
    1:         glEnable(GL_DEPTH_TEST)
               
               # Load shaders
    1:         self.program = self.load_shaders()
    1:         if not self.program:
                   logging.error("KaleidoTunnel: Failed to load shaders")
                   return
               
               # Generate geometry
    1:         self.generate_tunnel_geometry()
    1:         self.setup_buffers()
               
    1:         logging.info("KaleidoTunnel: Initialized successfully")
       
    1:     def paintGL(self):
               """Render the kaleidoscope tunnel"""
   84:         try:
   84:             if not self.program or not self.vao:
                       return
                   
                   # CLEAR WITH TRANSPARENT BACKGROUND
   84:             glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
                   
   84:             glUseProgram(self.program)
                   
                   # Set up matrices
   84:             current_time = time.time() - self.start_time
                   
                   # Model matrix (rotation around Z axis for kaleidoscope effect)
   84:             model = np.eye(4, dtype=np.float32)
   84:             rotation_angle = current_time * self.rotation_speed * 0.01
   84:             cos_a, sin_a = math.cos(rotation_angle), math.sin(rotation_angle)
   84:             model[0, 0] = cos_a
   84:             model[0, 1] = -sin_a
   84:             model[1, 0] = sin_a
   84:             model[1, 1] = cos_a
                   
                   # View matrix - camera moving forward through tunnel
   84:             forward_movement = (current_time * 2.0) % 1.0  # Cycle every 0.5 seconds
   84:             eye_z = 5.0 - forward_movement * 1.0
  168:             view = self.look_at(
   84:                 np.array([0, 0, eye_z]), 
   84:                 np.array([0, 0, 0]), 
   84:                 np.array([0, 1, 0])
                   )
                   
                   # Projection matrix
   84:             projection = self.perspective(60, 1.0, 0.1, 100.0)
                   
                   # Set uniforms
   84:             glUniformMatrix4fv(glGetUniformLocation(self.program, "model"), 1, GL_FALSE, model)
   84:             glUniformMatrix4fv(glGetUniformLocation(self.program, "view"), 1, GL_FALSE, view)
   84:             glUniformMatrix4fv(glGetUniformLocation(self.program, "projection"), 1, GL_FALSE, projection)
   84:             glUniform1f(glGetUniformLocation(self.program, "time"), current_time)
   84:             glUniform1f(glGetUniformLocation(self.program, "intensity"), self.color_intensity / 100.0)
                   
                   # Draw tunnel
   84:             glBindVertexArray(self.vao)
   84:             glDrawElements(GL_TRIANGLES, len(self.indices), GL_UNSIGNED_INT, None)
   84:             glBindVertexArray(0)
                   
   84:             glUseProgram(0)
                   
               except Exception as e:
                   logging.error(f"KaleidoTunnel paint error: {e}")
       
    1:     def look_at(self, eye, center, up):
               """Create look-at matrix"""
   84:         f = center - eye
   84:         f = f / np.linalg.norm(f)
   84:         u = up / np.linalg.norm(up)
   84:         s = np.cross(f, u)
   84:         s = s / np.linalg.norm(s)
   84:         u = np.cross(s, f)
               
  252:         return np.array([
   84:             [s[0], u[0], -f[0], 0],
   84:             [s[1], u[1], -f[1], 0],
   84:             [s[2], u[2], -f[2], 0],
   84:             [-np.dot(s, eye), -np.dot(u, eye), np.dot(f, eye), 1]
   84:         ], dtype=np.float32)
       
    1:     def perspective(self, fovy, aspect, near, far):
               """Create perspective matrix"""
   84:         f = 1.0 / math.tan(math.radians(fovy) / 2.0)
  252:         return np.array([
   84:             [f/aspect, 0, 0, 0],
   84:             [0, f, 0, 0],
   84:             [0, 0, (far+near)/(near-far), (2*far*near)/(near-far)],
   84:             [0, 0, -1, 0]
   84:         ], dtype=np.float32)
       
    1:     def resizeGL(self, w, h):
               """Handle resize"""
    1:         glViewport(0, 0, w, h)
       
    1:     def cleanup(self):
               """Clean up resources"""
    1:         try:
    1:             if self.program:
    1:                 glDeleteProgram(self.program)
    1:                 self.program = None
    1:             if self.vao:
    1:                 glDeleteVertexArrays(1, [self.vao])
    1:                 self.vao = None
    1:             if self.vbo:
    1:                 glDeleteBuffers(1, [self.vbo])
    1:                 self.vbo = None
    1:             if self.ebo:
    1:                 glDeleteBuffers(1, [self.ebo])
    1:                 self.ebo = None
    1:             logging.info("KaleidoTunnel: Cleaned up")
               except Exception as e:
                   logging.error(f"KaleidoTunnel cleanup error: {e}")
