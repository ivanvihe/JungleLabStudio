       # TODO: migrate to RenderBackend (ModernGL)
       # vortex_particles.py
    1: from PyQt6.QtGui import QSurfaceFormat
    1: from OpenGL.GL import *
    1: import numpy as np
    1: import ctypes
    1: import time
       
    1: from visuals.base_visualizer import BaseVisualizer
       
    1: VERT = """
       #version 330 core
       layout(location=0) in vec3 aPos;
       layout(location=1) in float aSize;
       layout(location=2) in float aPhase;
       
       uniform mat4 projection, view, model;
       uniform float u_time;
       uniform float u_spin;
       uniform float u_spread;
       
       out float vPhase;
       void main(){
           // spin around Y
           float ang = u_time*0.5*u_spin + aPhase;
           mat2 R = mat2(cos(ang), -sin(ang), sin(ang), cos(ang));
           vec2 xy = R * aPos.xz;
           vec3 p = vec3(xy.x, aPos.y, xy.y);
           p.xy *= (1.0 + u_spread*0.5*sin(u_time*0.7 + aPhase));
           gl_Position = projection * view * model * vec4(p,1.0);
           gl_PointSize = aSize;
           vPhase = aPhase;
       }
       """
       
    1: FRAG = """
       #version 330 core
       in float vPhase;
       out vec4 FragColor;
       uniform float u_time;
       uniform int   u_palette;
       
       vec3 pal(float t, int m){
           if(m==0) return vec3(0.6+0.4*sin(t), 0.4+0.6*sin(t+2.1), 1.0);
           if(m==1) return vec3(0.9, 0.5+0.5*sin(t*1.7), 0.2);
           return vec3(0.2, 0.9, 0.6+0.4*sin(t*2.0));
       }
       void main(){
           // soft circular falloff
           vec2 uv = gl_PointCoord*2.0 - 1.0;
           float d = dot(uv,uv);
           float alpha = smoothstep(1.0, 0.0, d);
           vec3 col = pal(u_time + vPhase, u_palette);
           FragColor = vec4(col, alpha);
       }
       """
       
    2: class VortexParticlesVisualizer(BaseVisualizer):
    1:     visual_name = "Vortex Particles"
    1:     def __init__(self, parent=None):
    1:         super().__init__(parent)
               
    1:         self.program = None
    1:         self.vao = None
    1:         self.vbo = None
    1:         self.count = 2000
    1:         self.spin = 1.0
    1:         self.spread = 0.6
    1:         self.palette = 0
    1:         self.start = time.time()
       
    1:     def get_controls(self):
    2:         return {
    2:             "Count": {"type":"slider","min":300,"max":8000,"value":self.count},
    2:             "Spin": {"type":"slider","min":10,"max":300,"value":int(self.spin*100)},
    2:             "Spread": {"type":"slider","min":0,"max":200,"value":int(self.spread*100)},
    2:             "Palette": {"type":"dropdown","options":["Neon","Fire","Mint"],"value":self.palette},
               }
       
    1:     def update_control(self, name, value):
               if name=="Count": self.count = int(value); self._spawn(); self._setup()
               elif name=="Spin": self.spin = float(value)/100.0
               elif name=="Spread": self.spread = float(value)/100.0
               elif name=="Palette": self.palette = int(value)
       
    1:     def perspective(self, fov, aspect, near, far):
               """Create a perspective projection matrix"""
   89:         fov_rad = np.radians(fov)
   89:         f = np.cos(fov_rad/2) / np.sin(fov_rad/2)
               
   89:         matrix = np.zeros((4, 4), dtype=np.float32)
   89:         matrix[0, 0] = f / aspect
   89:         matrix[1, 1] = f
   89:         matrix[2, 2] = (far + near) / (near - far)
   89:         matrix[2, 3] = (2 * far * near) / (near - far)
   89:         matrix[3, 2] = -1
               
   89:         return matrix
       
    1:     def lookAt(self, eye, center, up):
               """Create a look-at view matrix"""
   89:         f = center - eye
   89:         f = f / np.linalg.norm(f)
               
   89:         up = up / np.linalg.norm(up)
   89:         s = np.cross(f, up)
   89:         s = s / np.linalg.norm(s)
   89:         u = np.cross(s, f)
               
   89:         matrix = np.identity(4, dtype=np.float32)
   89:         matrix[0, 0] = s[0]
   89:         matrix[1, 0] = s[1]
   89:         matrix[2, 0] = s[2]
   89:         matrix[0, 1] = u[0]
   89:         matrix[1, 1] = u[1]
   89:         matrix[2, 1] = u[2]
   89:         matrix[0, 2] = -f[0]
   89:         matrix[1, 2] = -f[1]
   89:         matrix[2, 2] = -f[2]
   89:         matrix[3, 0] = -np.dot(s, eye)
   89:         matrix[3, 1] = -np.dot(u, eye)
   89:         matrix[3, 2] = np.dot(f, eye)
               
   89:         return matrix
       
    1:     def _spawn(self):
               # pos (3) + size (1) + phase (1)
    1:         r = np.random.rand(self.count).astype(np.float32)
    1:         theta = np.random.rand(self.count).astype(np.float32)*np.pi*2
    1:         y = (np.random.rand(self.count).astype(np.float32)-0.5)*1.6
    1:         rad = 0.2 + 2.8*r
    1:         x = rad*np.cos(theta); z = rad*np.sin(theta)
    1:         pos = np.stack([x, y, z], axis=1).astype(np.float32)
    1:         size = (2.0 + 3.0*(1.0-r)).astype(np.float32)
    1:         phase = (np.random.rand(self.count).astype(np.float32)*6.2831853)
    1:         self.data = np.zeros((self.count, 5), dtype=np.float32)
    1:         self.data[:,0:3] = pos
    1:         self.data[:,3] = size
    1:         self.data[:,4] = phase
       
    1:     def initializeGL(self):
    1:         glEnable(GL_PROGRAM_POINT_SIZE)
    1:         glEnable(GL_BLEND)
    1:         glBlendFunc(GL_SRC_ALPHA, GL_ONE)
    1:         self._spawn()
               # compile
    1:         vs = glCreateShader(GL_VERTEX_SHADER); glShaderSource(vs, VERT); glCompileShader(vs)
    1:         fs = glCreateShader(GL_FRAGMENT_SHADER); glShaderSource(fs, FRAG); glCompileShader(fs)
    1:         self.program = glCreateProgram()
    1:         glAttachShader(self.program, vs); glAttachShader(self.program, fs); glLinkProgram(self.program)
    1:         glDeleteShader(vs); glDeleteShader(fs)
    1:         self._setup()
       
    1:     def _setup(self):
    1:         if self.vao: glDeleteVertexArrays(1,[self.vao])
    1:         if self.vbo: glDeleteBuffers(1,[self.vbo])
    1:         self.vao = glGenVertexArrays(1); glBindVertexArray(self.vao)
    1:         self.vbo = glGenBuffers(1); glBindBuffer(GL_ARRAY_BUFFER, self.vbo)
    1:         glBufferData(GL_ARRAY_BUFFER, self.data.nbytes, self.data, GL_DYNAMIC_DRAW)
    1:         stride = 5*ctypes.sizeof(GLfloat)
    1:         glVertexAttribPointer(0,3,GL_FLOAT,GL_FALSE,stride,ctypes.c_void_p(0)); glEnableVertexAttribArray(0)
    1:         glVertexAttribPointer(1,1,GL_FLOAT,GL_FALSE,stride,ctypes.c_void_p(3*ctypes.sizeof(GLfloat))); glEnableVertexAttribArray(1)
    1:         glVertexAttribPointer(2,1,GL_FLOAT,GL_FALSE,stride,ctypes.c_void_p(4*ctypes.sizeof(GLfloat))); glEnableVertexAttribArray(2)
    1:         glBindVertexArray(0)
       
    1:     def paintGL(self):
   89:         glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
   89:         glUseProgram(self.program)
   89:         t = time.time()-self.start
   89:         glUniform1f(glGetUniformLocation(self.program,"u_time"), t)
   89:         glUniform1f(glGetUniformLocation(self.program,"u_spin"), self.spin)
   89:         glUniform1f(glGetUniformLocation(self.program,"u_spread"), self.spread)
   89:         glUniform1i(glGetUniformLocation(self.program,"u_palette"), self.palette)
       
   89:         projection = self.perspective(60, 1.0, 0.1, 100.0)
   89:         view = self.lookAt(np.array([0, 0.6, 6.0]), np.array([0,0,0]), np.array([0,1,0]))
   89:         model = np.identity(4, dtype=np.float32)
   89:         glUniformMatrix4fv(glGetUniformLocation(self.program,"projection"),1,GL_FALSE,projection)
   89:         glUniformMatrix4fv(glGetUniformLocation(self.program,"view"),1,GL_FALSE,view)
   89:         glUniformMatrix4fv(glGetUniformLocation(self.program,"model"),1,GL_FALSE,model)
       
   89:         glBindVertexArray(self.vao)
   89:         glDrawArrays(GL_POINTS, 0, self.count)
   89:         glBindVertexArray(0)
               
       
    2:     def resizeGL(self,w,h): glViewport(0,0,w,h)
       
    1:     def cleanup(self):
    1:         if self.program: glDeleteProgram(self.program)
    1:         if self.vbo: glDeleteBuffers(1,[self.vbo])
    1:         if self.vao: glDeleteVertexArrays(1,[self.vao])
