       # TODO: migrate to RenderBackend (ModernGL)
       # visuals/presets/intro_background.py
    1: import logging
    1: import numpy as np
    1: import ctypes
    1: import time
    1: import math
    1: import random
    1: import string
    1: from OpenGL.GL import *
    1: from ..base_visualizer import BaseVisualizer
       
    2: class IntroBackgroundVisualizer(BaseVisualizer):
    1:     visual_name = "Intro Background"
           
    1:     def __init__(self):
    1:         super().__init__()
    1:         self.shader_program = None
    1:         self.vao = None
    1:         self.vbo = None
    1:         self.start_time = time.time()
    1:         self.initialized = False
               
               # Grid configuration
    1:         self.grid_width = 80
    1:         self.grid_height = 25
    1:         self.total_chars = self.grid_width * self.grid_height
               
               # Character data arrays
    1:         self.current_chars = []  # Current characters displayed
    1:         self.target_chars = []   # Target characters to transition to
    1:         self.transition_progress = []  # 0.0 to 1.0 transition progress
    1:         self.last_change_time = []  # When each character last changed
               
               # Animation state
    1:         self.fill_progress = 0.0  # How much of screen is filled (0.0 to 1.0)
    1:         self.fill_speed = 0.5     # Characters per second during fill
    1:         self.reveal_started = False
    1:         self.reveal_pending = False
    1:         self.reveal_progress = 0.0
               
               # Control parameters
    1:         self.fill_rate = 1.0
    1:         self.change_frequency = 1.0
    1:         self.transition_speed = 2.0
    1:         self.brightness = 1.0
               
               # Character set
    1:         self.charset = string.ascii_letters + string.digits + "!@#$%^&*()_+-=[]{}|;:,.<>?"
               
               # ROBOTICA reveal
    1:         self.robotica_text = "ROBOTICA"
    1:         self.robotica_positions = []
               
    1:         logging.info("IntroBackgroundVisualizer created")
       
    1:     def initializeGL(self):
               """Initialize OpenGL resources"""
    1:         try:
    1:             logging.debug("IntroBackgroundVisualizer.initializeGL called")
                   
                   # Clear any existing GL errors
    1:             while glGetError() != GL_NO_ERROR:
                       pass
                   
                   # Set up OpenGL state - black background
    1:             glClearColor(0.0, 0.0, 0.0, 1.0)
    1:             glEnable(GL_BLEND)
    1:             glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
    1:             glDisable(GL_DEPTH_TEST)
                   
                   # Initialize character grid
    1:             self.init_character_grid()
                   
                   # Load shaders
    1:             if not self.load_shaders():
                       logging.error("Failed to load shaders")
                       return
                   
                   # Setup geometry
    1:             if not self.setup_geometry():
                       logging.error("Failed to setup geometry")
                       return
                   
    1:             self.initialized = True
    1:             logging.info("âœ… IntroBackgroundVisualizer initialized successfully")
                   
               except Exception as e:
                   logging.error(f"Error in IntroBackgroundVisualizer.initializeGL: {e}")
                   import traceback
                   traceback.print_exc()
       
    1:     def init_character_grid(self):
               """Initialize the character grid"""
    1:         self.current_chars = [' '] * self.total_chars
    1:         self.target_chars = [' '] * self.total_chars
    1:         self.transition_progress = [1.0] * self.total_chars
    1:         self.last_change_time = [0.0] * self.total_chars
               
               # Calculate ROBOTICA positions (center of screen)
    1:         self.center_row = self.grid_height // 2
    1:         self.text_length = len(self.robotica_text)
    1:         self.start_col = (self.grid_width - self.text_length) // 2
       
    1:         self.robotica_positions = []
    9:         for i, char in enumerate(self.robotica_text):
    8:             col = self.start_col + i
    8:             index = self.center_row * self.grid_width + col
    8:             self.robotica_positions.append(index)
       
    1:     def load_shaders(self):
               """Load and compile shaders for character rendering"""
    1:         try:
    1:             vertex_shader_source = """
                   #version 330 core
                   layout (location = 0) in vec2 aPos;
                   layout (location = 1) in vec2 aTexCoord;
                   layout (location = 2) in float aChar;
                   layout (location = 3) in float aTransition;
                   
                   uniform float time;
                   uniform float brightness;
                   
                   out vec2 texCoord;
                   out float charCode;
                   out float transition;
                   out vec3 color;
                   
                   void main()
                   {
                       gl_Position = vec4(aPos, 0.0, 1.0);
                       texCoord = aTexCoord;
                       charCode = aChar;
                       transition = aTransition;
                       
                       // Colorful characters on black background
                       float rand = fract(sin(dot(aPos.xy, vec2(12.9898, 78.233)) + aChar) * 43758.5453);
                       vec3 baseColor = vec3(fract(rand + 0.31), fract(rand + 0.63), fract(rand + 0.97));
                       float alpha = brightness * (0.8 + 0.2 * sin(time * 2.0 + aPos.x * 10.0));
                       color = baseColor * alpha;
                   }
                   """
                   
    1:             fragment_shader_source = """
                   #version 330 core
                   in vec2 texCoord;
                   in float charCode;
                   in float transition;
                   in vec3 color;
                   
                   out vec4 FragColor;
                   
                   // Simple character rendering using texture coordinates
                   float drawChar(vec2 uv, float c) {
                       // Very basic character rendering
                       // We'll create simple shapes for different character codes
                       vec2 p = uv * 2.0 - 1.0; // Convert to -1,1 range
                       
                       float char_alpha = 0.0;
                       
                       // Different patterns for different character ranges
                       float char_mod = mod(c, 10.0);
                       
                       if (char_mod < 2.0) {
                           // Rectangle pattern
                           char_alpha = step(abs(p.x), 0.6) * step(abs(p.y), 0.8);
                       } else if (char_mod < 4.0) {
                           // Circle pattern
                           char_alpha = 1.0 - smoothstep(0.4, 0.6, length(p));
                       } else if (char_mod < 6.0) {
                           // Cross pattern
                           char_alpha = step(abs(p.x), 0.2) + step(abs(p.y), 0.2);
                       } else if (char_mod < 8.0) {
                           // Diagonal lines
                           float d1 = abs(p.x - p.y);
                           float d2 = abs(p.x + p.y);
                           char_alpha = step(d1, 0.2) + step(d2, 0.2);
                       } else {
                           // Dots pattern
                           vec2 grid = floor(p * 3.0);
                           char_alpha = step(mod(grid.x + grid.y, 2.0), 0.5);
                       }
                       
                       return clamp(char_alpha, 0.0, 1.0);
                   }
                   
                   void main()
                   {
                       float char_alpha = drawChar(texCoord, charCode);
                       
                       // Apply transition effect (fade/blur)
                       float transition_alpha = 1.0;
                       if (transition < 1.0) {
                           // Create blur/fade effect during transition
                           vec2 blur_offset = vec2(sin(transition * 3.14159), cos(transition * 3.14159)) * 0.1;
                           float blur_alpha = drawChar(texCoord + blur_offset, charCode);
                           char_alpha = mix(blur_alpha * 0.5, char_alpha, transition);
                           transition_alpha = 0.5 + 0.5 * transition;
                       }
                       
                       vec3 final_color = color;
                       float final_alpha = char_alpha * transition_alpha;
                       
                       FragColor = vec4(final_color, final_alpha);
                   }
                   """
                   
                   # Compile vertex shader
    1:             vertex_shader = glCreateShader(GL_VERTEX_SHADER)
    1:             glShaderSource(vertex_shader, vertex_shader_source)
    1:             glCompileShader(vertex_shader)
                   
    1:             if not glGetShaderiv(vertex_shader, GL_COMPILE_STATUS):
                       error = glGetShaderInfoLog(vertex_shader).decode()
                       logging.error(f"Vertex shader compilation failed: {error}")
                       return False
                   
                   # Compile fragment shader
    1:             fragment_shader = glCreateShader(GL_FRAGMENT_SHADER)
    1:             glShaderSource(fragment_shader, fragment_shader_source)
    1:             glCompileShader(fragment_shader)
                   
    1:             if not glGetShaderiv(fragment_shader, GL_COMPILE_STATUS):
                       error = glGetShaderInfoLog(fragment_shader).decode()
                       logging.error(f"Fragment shader compilation failed: {error}")
                       return False
                   
                   # Link program
    1:             self.shader_program = glCreateProgram()
    1:             glAttachShader(self.shader_program, vertex_shader)
    1:             glAttachShader(self.shader_program, fragment_shader)
    1:             glLinkProgram(self.shader_program)
                   
    1:             if not glGetProgramiv(self.shader_program, GL_LINK_STATUS):
                       error = glGetProgramInfoLog(self.shader_program).decode()
                       logging.error(f"Shader program linking failed: {error}")
                       return False
                   
                   # Clean up shaders
    1:             glDeleteShader(vertex_shader)
    1:             glDeleteShader(fragment_shader)
                   
    1:             logging.debug("IntroBackgroundVisualizer shaders compiled successfully")
    1:             return True
                   
               except Exception as e:
                   logging.error(f"Error loading shaders: {e}")
                   return False
       
    1:     def setup_geometry(self):
               """Setup vertex data for character grid"""
    1:         try:
                   # Create vertices for each character position
    1:             vertices = []
                   
    1:             self.char_width = 2.0 / self.grid_width
    1:             self.char_height = 2.0 / self.grid_height
    1:             char_width = self.char_width
    1:             char_height = self.char_height
                   
   26:             for row in range(self.grid_height):
 2025:                 for col in range(self.grid_width):
                           # Calculate position (-1 to 1 range)
 2000:                     x = -1.0 + (col + 0.5) * char_width
 2000:                     y = 1.0 - (row + 0.5) * char_height
                           
                           # Create quad for this character
 2000:                     half_w = char_width * 0.4
 2000:                     half_h = char_height * 0.4
                           
                           # Triangle 1
 4000:                     vertices.extend([
 2000:                         x - half_w, y - half_h, 0.0, 0.0, 0.0, 0.0,  # pos, texcoord, char, transition
 2000:                         x + half_w, y - half_h, 1.0, 0.0, 0.0, 0.0,
 2000:                         x - half_w, y + half_h, 0.0, 1.0, 0.0, 0.0
                           ])
                           
                           # Triangle 2
 4000:                     vertices.extend([
 2000:                         x + half_w, y - half_h, 1.0, 0.0, 0.0, 0.0,
 2000:                         x + half_w, y + half_h, 1.0, 1.0, 0.0, 0.0,
 2000:                         x - half_w, y + half_h, 0.0, 1.0, 0.0, 0.0
                           ])
                   
    1:             self.vertices = np.array(vertices, dtype=np.float32)
                   
                   # Create and bind VAO
    1:             self.vao = glGenVertexArrays(1)
    1:             glBindVertexArray(self.vao)
                   
                   # Create and bind VBO
    1:             self.vbo = glGenBuffers(1)
    1:             glBindBuffer(GL_ARRAY_BUFFER, self.vbo)
    1:             glBufferData(GL_ARRAY_BUFFER, self.vertices.nbytes, self.vertices, GL_DYNAMIC_DRAW)
                   
                   # Set vertex attributes
    1:             stride = 6 * 4  # 6 floats per vertex
                   
                   # Position
    1:             glEnableVertexAttribArray(0)
    1:             glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, stride, ctypes.c_void_p(0))
                   # Texture coordinates
    1:             glEnableVertexAttribArray(1)
    1:             glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, stride, ctypes.c_void_p(2 * 4))
                   # Character code
    1:             glEnableVertexAttribArray(2)
    1:             glVertexAttribPointer(2, 1, GL_FLOAT, GL_FALSE, stride, ctypes.c_void_p(4 * 4))
                   # Transition
    1:             glEnableVertexAttribArray(3)
    1:             glVertexAttribPointer(3, 1, GL_FLOAT, GL_FALSE, stride, ctypes.c_void_p(5 * 4))
                   
                   # Unbind
    1:             glBindVertexArray(0)
    1:             glBindBuffer(GL_ARRAY_BUFFER, 0)
                   
    1:             logging.debug("IntroBackgroundVisualizer geometry setup complete")
    1:             return True
                   
               except Exception as e:
                   logging.error(f"Error setting up geometry: {e}")
                   return False
       
    1:     def update_animation(self, current_time):
               """Update the animation state"""
   92:         dt = current_time - (getattr(self, 'last_update_time', 0))
   92:         self.last_update_time = current_time
               
               # Phase 1: Fill screen with random characters
   92:         if self.fill_progress < 1.0:
   55:             self.fill_progress += self.fill_rate * dt
   55:             chars_to_fill = int(self.fill_progress * self.total_chars)
                   
                   # Add new random characters leaving occasional gaps
55675:             for i in range(min(chars_to_fill, self.total_chars)):
55620:                 if self.current_chars[i] == ' ' and random.random() > 0.15:
 1997:                     self.current_chars[i] = random.choice(self.charset)
 1997:                     self.target_chars[i] = self.current_chars[i]
 1997:                     self.transition_progress[i] = 1.0
 1997:                     self.last_change_time[i] = current_time
               
               # Phase 2: Random character changes
184092:         for i in range(self.total_chars):
184000:             if self.current_chars[i] != ' ':
                       # Check if it's time to change this character
129150:                 time_since_change = current_time - self.last_change_time[i]
129150:                 change_interval = 2.0 + random.random() * 3.0  # 2-5 seconds as requested
129150:                 change_interval /= self.change_frequency
                       
129150:                 if time_since_change > change_interval and self.transition_progress[i] >= 1.0:
                           # Start transition to new character
                           if i not in self.robotica_positions or not self.reveal_started:
                               self.target_chars[i] = random.choice(self.charset)
                               self.transition_progress[i] = 0.0
                               self.last_change_time[i] = current_time
                       
                       # Update transition progress
129150:                 if self.transition_progress[i] < 1.0:
                           self.transition_progress[i] += self.transition_speed * dt
                           if self.transition_progress[i] >= 1.0:
                               self.transition_progress[i] = 1.0
                               self.current_chars[i] = self.target_chars[i]
               
               # Phase 3: Reveal ROBOTICA when triggered
   92:         if self.reveal_pending and self.fill_progress >= 1.0 and not self.reveal_started:
                   self.reveal_started = True
                   anim_time = current_time  # use current animation time
                   for i, pos in enumerate(self.robotica_positions):
                       if i < len(self.robotica_text):
                           self.target_chars[pos] = self.robotica_text[i]
                           self.transition_progress[pos] = 0.0
                           self.last_change_time[pos] = anim_time
       
    1:     def update_vertex_data(self):
               """Update vertex buffer with current character data"""
   92:         try:
                   # Update character codes and transitions in vertex buffer
   92:             vertex_count = self.total_chars * 6  # 6 vertices per character
                   
184092:             for char_idx in range(self.total_chars):
                       # Get character code
184000:                 char_code = ord(self.current_chars[char_idx]) if self.current_chars[char_idx] != ' ' else 32
184000:                 transition = self.transition_progress[char_idx]
                       
                       # Update 6 vertices for this character
1288000:                 for vertex_idx in range(6):
1104000:                     base_idx = (char_idx * 6 + vertex_idx) * 6  # 6 floats per vertex
1104000:                     self.vertices[base_idx + 4] = float(char_code)  # Character code
1104000:                     self.vertices[base_idx + 5] = transition  # Transition progress
                   
                   # Upload to GPU
   92:             glBindBuffer(GL_ARRAY_BUFFER, self.vbo)
   92:             glBufferSubData(GL_ARRAY_BUFFER, 0, self.vertices.nbytes, self.vertices)
   92:             glBindBuffer(GL_ARRAY_BUFFER, 0)
                   
               except Exception as e:
                   logging.error(f"Error updating vertex data: {e}")
       
    1:     def draw_robotica_background(self):
               """Draw semi-transparent backdrop and border for ROBOTICA text"""
               try:
                   char_w = getattr(self, 'char_width', 2.0 / self.grid_width)
                   char_h = getattr(self, 'char_height', 2.0 / self.grid_height)
                   x_start = -1.0 + (self.start_col - 0.5) * char_w
                   x_end = x_start + (self.text_length + 1.0) * char_w
                   y_top = 1.0 - (self.center_row - 0.5) * char_h
                   y_bottom = y_top - (1.5 * char_h)
       
                   # Background rectangle
                   glColor4f(0.0, 0.0, 0.0, 0.5)
                   glBegin(GL_TRIANGLE_FAN)
                   glVertex2f(x_start, y_top)
                   glVertex2f(x_end, y_top)
                   glVertex2f(x_end, y_bottom)
                   glVertex2f(x_start, y_bottom)
                   glEnd()
       
                   # Border
                   glColor4f(1.0, 1.0, 1.0, 0.8)
                   glLineWidth(2.0)
                   glBegin(GL_LINE_LOOP)
                   glVertex2f(x_start, y_top)
                   glVertex2f(x_end, y_top)
                   glVertex2f(x_end, y_bottom)
                   glVertex2f(x_start, y_bottom)
                   glEnd()
       
                   glColor4f(1.0, 1.0, 1.0, 1.0)
       
               except Exception as e:
                   logging.error(f"Error drawing ROBOTICA background: {e}")
       
    1:     def paintGL(self):
               """Render the visualization"""
   92:         try:
   92:             if not self.initialized or not self.shader_program:
                       # Fallback rendering
                       glClearColor(0.0, 0.0, 0.0, 1.0)
                       glClear(GL_COLOR_BUFFER_BIT)
                       return
       
                   # Clear with black background
   92:             glClearColor(0.0, 0.0, 0.0, 1.0)
   92:             glClear(GL_COLOR_BUFFER_BIT)
                   
                   # Update animation
   92:             current_time = time.time() - self.start_time
   92:             self.update_animation(current_time)
   92:             self.update_vertex_data()
       
                   # Draw overlay background if revealing text
   92:             if self.reveal_started:
                       self.draw_robotica_background()
       
                   # Use shader program
   92:             glUseProgram(self.shader_program)
                   
                   # Update uniforms
   92:             glUniform1f(glGetUniformLocation(self.shader_program, "time"), current_time)
   92:             glUniform1f(glGetUniformLocation(self.shader_program, "brightness"), self.brightness)
                   
                   # Draw characters
   92:             if self.vao:
   92:                 glBindVertexArray(self.vao)
   92:                 glDrawArrays(GL_TRIANGLES, 0, self.total_chars * 6)
   92:                 glBindVertexArray(0)
                   
                   # Clean up
   92:             glUseProgram(0)
                   
               except Exception as e:
                   # Only log errors occasionally to avoid spam
                   if not hasattr(self, '_last_error_time') or \
                      time.time() - self._last_error_time > 5:
                       logging.error(f"IntroBackground paint error: {e}")
                       self._last_error_time = time.time()
       
                   # Fallback rendering
                   glClearColor(0.0, 0.0, 0.0, 1.0)
                   glClear(GL_COLOR_BUFFER_BIT)
       
    1:     def resizeGL(self, width, height):
               """Handle resize"""
    1:         glViewport(0, 0, width, height)
       
    1:     def cleanup(self):
               """Clean up OpenGL resources"""
    1:         try:
    1:             logging.debug("Cleaning up IntroBackgroundVisualizer")
                   
                   # Delete shader program
    1:             if self.shader_program:
    1:                 try:
    1:                     if glIsProgram(self.shader_program):
    1:                         glDeleteProgram(self.shader_program)
                       except:
                           pass
                       finally:
    1:                     self.shader_program = None
                   
                   # Delete VAO
    1:             if self.vao:
    1:                 try:
    1:                     glDeleteVertexArrays(1, [self.vao])
                       except:
                           pass
                       finally:
    1:                     self.vao = None
                   
                   # Delete VBO
    1:             if self.vbo:
    1:                 try:
    1:                     glDeleteBuffers(1, [self.vbo])
                       except:
                           pass
                       finally:
    1:                     self.vbo = None
                   
    1:             self.initialized = False
    1:             logging.debug("IntroBackgroundVisualizer cleanup complete")
                   
               except Exception as e:
                   logging.debug(f"Cleanup error (non-critical): {e}")
       
    1:     def get_controls(self):
               """Return available controls"""
    2:         return {
    2:             "Fill Rate": {
    2:                 "type": "slider",
    2:                 "min": 1,
    2:                 "max": 50,
    2:                 "value": int(self.fill_rate * 10),
    2:                 "default": 10
                   },
    2:             "Change Frequency": {
    2:                 "type": "slider",
    2:                 "min": 1,
    2:                 "max": 50,
    2:                 "value": int(self.change_frequency * 10),
    2:                 "default": 10
                   },
    2:             "Transition Speed": {
    2:                 "type": "slider",
    2:                 "min": 1,
    2:                 "max": 50,
    2:                 "value": int(self.transition_speed * 10),
    2:                 "default": 20
                   },
    2:             "Brightness": {
    2:                 "type": "slider",
    2:                 "min": 1,
    2:                 "max": 20,
    2:                 "value": int(self.brightness * 10),
    2:                 "default": 10
                   }
               }
       
    1:     def update_control(self, name, value):
               """Update a control value"""
               try:
                   if name == "Fill Rate":
                       self.fill_rate = value / 10.0
                       logging.debug(f"Fill rate updated to {self.fill_rate}")
                   elif name == "Change Frequency":
                       self.change_frequency = value / 10.0
                       logging.debug(f"Change frequency updated to {self.change_frequency}")
                   elif name == "Transition Speed":
                       self.transition_speed = value / 10.0
                       logging.debug(f"Transition speed updated to {self.transition_speed}")
                   elif name == "Brightness":
                       self.brightness = value / 10.0
                       logging.debug(f"Brightness updated to {self.brightness}")
               except Exception as e:
                   logging.error(f"Error updating control {name}: {e}")
       
    1:     def trigger_action(self, action_name):
               """Handle custom actions triggered via MIDI"""
               if action_name == "show_ROBOTICA_text":
                   self.reveal_pending = True
