       # TODO: migrate to RenderBackend (ModernGL)
       # visuals/presets/building_madness.py
    1: from OpenGL.GL import *
    1: from OpenGL.GLU import *
    1: import numpy as np
    1: import ctypes
    1: import os
    1: import logging
       
    1: from visuals.base_visualizer import BaseVisualizer
       
    2: class BuildingMadnessVisualizer(BaseVisualizer):
    1:     visual_name = "Building Madness"
           
    1:     def __init__(self, *args, **kwargs):
    1:         super().__init__(*args, **kwargs)
    1:         self.shader_program = None
    1:         self.VBO = None
    1:         self.VAO = None
    1:         self.EBO = None
    1:         self.vertices = None
    1:         self.indices = None
    1:         self.original_vertices = None
    1:         self.time = 0.0
    1:         self.room_type = 0
    1:         self.speed = 1.0
    1:         self.intensity = 1.0
    1:         self.complexity = 1.0
    1:         self.effect_mode = 0
       
    1:     def get_controls(self):
    2:         return {
    2:             "Room Type": {
    2:                 "type": "dropdown",
    2:                 "options": ["Cube Room", "Sphere Room", "Tunnel Room", "Pyramid Room", "Crystal Room"],
    2:                 "value": self.room_type,
                   },
    2:             "Speed": {
    2:                 "type": "slider",
    2:                 "min": 1,
    2:                 "max": 100,
    2:                 "value": int(self.speed * 20),
                   },
    2:             "Intensity": {
    2:                 "type": "slider",
    2:                 "min": 1,
    2:                 "max": 100,
    2:                 "value": int(self.intensity * 50),
                   },
    2:             "Complexity": {
    2:                 "type": "slider",
    2:                 "min": 1,
    2:                 "max": 100,
    2:                 "value": int(self.complexity * 50),
                   },
    2:             "Effect Mode": {
    2:                 "type": "dropdown",
    2:                 "options": ["Wave Patterns", "Fractal Growth", "Mirror Kaleidoscope", "Digital Rain", "Plasma Flow"],
    2:                 "value": self.effect_mode,
                   }
               }
       
    1:     def update_control(self, name, value):
               if name == "Room Type":
                   if self.room_type != int(value):
                       self.room_type = int(value)
                       self.create_room()
               elif name == "Speed":
                   self.speed = float(value) / 20.0
               elif name == "Intensity":
                   self.intensity = float(value) / 50.0
               elif name == "Complexity":
                   if abs(self.complexity - float(value) / 50.0) > 0.1:
                       self.complexity = float(value) / 50.0
                       self.create_room()
               elif name == "Effect Mode":
                   self.effect_mode = int(value)
       
    1:     def initializeGL(self):
    1:         print("BuildingMadnessVisualizer.initializeGL called")
               # TRANSPARENT BACKGROUND FOR MIXING
    1:         glClearColor(0.0, 0.0, 0.0, 0.0)  # Alpha = 0 for transparency
    1:         glEnable(GL_DEPTH_TEST)
    1:         glEnable(GL_BLEND)
    1:         glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
    1:         glDisable(GL_CULL_FACE)  # Important to see inside faces
       
    1:         self.load_shaders()
    1:         self.create_room()
       
    1:     def load_shaders(self):
    1:         try:
                   # Use inline shaders to avoid file loading issues
    1:             vertex_shader_source = """
                   #version 330 core
                   layout (location = 0) in vec3 aPos;
                   layout (location = 1) in vec4 aColor;
                   
                   uniform mat4 projection;
                   uniform mat4 view;
                   uniform mat4 model;
                   
                   out vec4 vColor;
                   
                   void main()
                   {
                       gl_Position = projection * view * model * vec4(aPos, 1.0);
                       vColor = aColor;
                   }
                   """
                   
    1:             fragment_shader_source = """
                   #version 330 core
                   in vec4 vColor;
                   out vec4 FragColor;
                   
                   void main()
                   {
                       FragColor = vColor;
                   }
                   """
       
    1:             vertex_shader = glCreateShader(GL_VERTEX_SHADER)
    1:             glShaderSource(vertex_shader, vertex_shader_source)
    1:             glCompileShader(vertex_shader)
       
    1:             fragment_shader = glCreateShader(GL_FRAGMENT_SHADER)
    1:             glShaderSource(fragment_shader, fragment_shader_source)
    1:             glCompileShader(fragment_shader)
       
    1:             self.shader_program = glCreateProgram()
    1:             glAttachShader(self.shader_program, vertex_shader)
    1:             glAttachShader(self.shader_program, fragment_shader)
    1:             glLinkProgram(self.shader_program)
       
    1:             glDeleteShader(vertex_shader)
    1:             glDeleteShader(fragment_shader)
    1:             print("BuildingMadness shaders loaded successfully")
               except Exception as e:
                   print(f"BuildingMadness shader loading error: {e}")
       
    1:     def create_cube_room(self):
               """Create a cube room with subdivided walls for effects"""
    1:         vertices = []
    1:         indices = []
               
    1:         size = 10.0
    1:         subdivisions = max(10, int(20 * self.complexity))
               
               # Define the 6 walls of the cube (inside faces)
    1:         walls = [
                   # Floor (looking up at it)
    1:             {'vertices': [[-size, -size, -size], [size, -size, -size], [size, -size, size], [-size, -size, size]], 'normal': [0, 1, 0]},
                   # Ceiling (looking down at it) 
    1:             {'vertices': [[-size, size, -size], [-size, size, size], [size, size, size], [size, size, -size]], 'normal': [0, -1, 0]},
                   # Front wall
    1:             {'vertices': [[-size, -size, size], [size, -size, size], [size, size, size], [-size, size, size]], 'normal': [0, 0, -1]},
                   # Back wall
    1:             {'vertices': [[size, -size, -size], [-size, -size, -size], [-size, size, -size], [size, size, -size]], 'normal': [0, 0, 1]},
                   # Left wall
    1:             {'vertices': [[-size, -size, -size], [-size, -size, size], [-size, size, size], [-size, size, -size]], 'normal': [1, 0, 0]},
                   # Right wall
    1:             {'vertices': [[size, -size, size], [size, -size, -size], [size, size, -size], [size, size, size]], 'normal': [-1, 0, 0]}
               ]
               
    7:         for wall in walls:
    6:             start_vertex = len(vertices) // 7
    6:             wall_verts = wall['vertices']
                   
                   # Create subdivided grid for this wall
  132:             for i in range(subdivisions + 1):
 2772:                 for j in range(subdivisions + 1):
 2646:                     u = i / subdivisions
 2646:                     v = j / subdivisions
                           
                           # Bilinear interpolation
 2646:                     p1 = np.array(wall_verts[0]) * (1-u) * (1-v)
 2646:                     p2 = np.array(wall_verts[1]) * u * (1-v)
 2646:                     p3 = np.array(wall_verts[2]) * u * v
 2646:                     p4 = np.array(wall_verts[3]) * (1-u) * v
                           
 2646:                     pos = p1 + p2 + p3 + p4
                           
                           # Initial color based on position and wall with transparency
 2646:                     r = 0.5 + 0.3 * np.sin(u * np.pi)
 2646:                     g = 0.5 + 0.3 * np.cos(v * np.pi)
 2646:                     b = 0.7
 2646:                     alpha = 0.8  # Semi-transparent for mixing
                           
 2646:                     vertices.extend([pos[0], pos[1], pos[2], r, g, b, alpha])
                   
                   # Create triangles for this wall
  126:             for i in range(subdivisions):
 2520:                 for j in range(subdivisions):
 2400:                     base = start_vertex + i * (subdivisions + 1) + j
                           
                           # Two triangles per quad
 2400:                     indices.extend([base, base + 1, base + subdivisions + 1])
 2400:                     indices.extend([base + 1, base + subdivisions + 2, base + subdivisions + 1])
               
    1:         return vertices, indices
       
    1:     def create_sphere_room(self):
               """Create a spherical room"""
               vertices = []
               indices = []
               
               radius = 8.0
               lat_segments = max(20, int(30 * self.complexity))
               lon_segments = max(30, int(40 * self.complexity))
               
               # Create sphere vertices (inside view)
               for lat in range(lat_segments + 1):
                   theta = lat * np.pi / lat_segments
                   for lon in range(lon_segments + 1):
                       phi = lon * 2 * np.pi / lon_segments
                       
                       x = radius * np.sin(theta) * np.cos(phi)
                       y = radius * np.cos(theta)
                       z = radius * np.sin(theta) * np.sin(phi)
                       
                       # Color based on spherical coordinates
                       r = 0.5 + 0.5 * np.sin(theta * 2)
                       g = 0.5 + 0.5 * np.cos(phi)
                       b = 0.5 + 0.5 * np.sin(phi * 2)
                       alpha = 0.8  # Semi-transparent
                       
                       vertices.extend([x, y, z, r, g, b, alpha])
               
               # Create triangles (note reversed winding for inside view)
               for lat in range(lat_segments):
                   for lon in range(lon_segments):
                       first = lat * (lon_segments + 1) + lon
                       second = first + lon_segments + 1
                       
                       # Reverse winding for inside view
                       indices.extend([first, second, first + 1])
                       indices.extend([second, second + 1, first + 1])
               
               return vertices, indices
       
    1:     def create_tunnel_room(self):
               """Create a cylindrical tunnel"""
               vertices = []
               indices = []
               
               radius = 6.0
               length = 20.0
               segments = max(30, int(50 * self.complexity))
               rings = max(20, int(30 * self.complexity))
               
               # Create tunnel
               for ring in range(rings + 1):
                   z = -length/2 + (ring / rings) * length
                   
                   for seg in range(segments + 1):
                       angle = seg * 2 * np.pi / segments
                       
                       x = radius * np.cos(angle)
                       y = radius * np.sin(angle)
                       
                       # Color based on position
                       r = 0.5 + 0.5 * np.sin(angle * 3)
                       g = 0.5 + 0.5 * np.cos(z * 0.2)
                       b = 0.8
                       alpha = 0.7  # Semi-transparent
                       
                       vertices.extend([x, y, z, r, g, b, alpha])
               
               # Create triangles (inside view)
               for ring in range(rings):
                   for seg in range(segments):
                       current = ring * (segments + 1) + seg
                       next_ring = (ring + 1) * (segments + 1) + seg
                       next_seg = ring * (segments + 1) + ((seg + 1) % (segments + 1))
                       next_both = (ring + 1) * (segments + 1) + ((seg + 1) % (segments + 1))
                       
                       # Reverse winding for inside view
                       indices.extend([current, next_seg, next_ring])
                       indices.extend([next_seg, next_both, next_ring])
               
               return vertices, indices
       
    1:     def create_pyramid_room(self):
               """Create a pyramid room"""
               vertices = []
               indices = []
               
               size = 8.0
               height = 10.0
               subdivisions = max(15, int(25 * self.complexity))
               
               # Base of pyramid (square)
               base_verts = [[-size, -height, -size], [size, -height, -size], [size, -height, size], [-size, -height, size]]
               
               # Create base with subdivisions
               start_vertex = len(vertices) // 7
               for i in range(subdivisions + 1):
                   for j in range(subdivisions + 1):
                       u = i / subdivisions
                       v = j / subdivisions
                       
                       # Base position
                       p1 = np.array(base_verts[0]) * (1-u) * (1-v)
                       p2 = np.array(base_verts[1]) * u * (1-v)
                       p3 = np.array(base_verts[2]) * u * v
                       p4 = np.array(base_verts[3]) * (1-u) * v
                       
                       pos = p1 + p2 + p3 + p4
                       
                       r = 0.8 * (1 - u * 0.3)
                       g = 0.6 * (1 - v * 0.3)
                       b = 0.9
                       alpha = 0.75  # Semi-transparent
                       
                       vertices.extend([pos[0], pos[1], pos[2], r, g, b, alpha])
               
               # Base triangles
               for i in range(subdivisions):
                   for j in range(subdivisions):
                       base = start_vertex + i * (subdivisions + 1) + j
                       indices.extend([base, base + subdivisions + 1, base + 1])
                       indices.extend([base + 1, base + subdivisions + 1, base + subdivisions + 2])
               
               return vertices, indices
       
    1:     def create_crystal_room(self):
               """Create a crystalline room"""
               vertices = []
               indices = []
               
               # Create multiple crystal faces
               num_faces = max(8, int(12 * self.complexity))
               radius = 8.0
               
               for face in range(num_faces):
                   angle = face * 2 * np.pi / num_faces
                   height_variation = np.sin(face * 1.5) * 2
                   
                   # Create crystal face
                   subdivisions = max(8, int(15 * self.complexity))
                   face_start = len(vertices) // 7
                   
                   for i in range(subdivisions + 1):
                       for j in range(subdivisions + 1):
                           u = i / subdivisions
                           v = j / subdivisions
                           
                           # Create faceted surface
                           x = radius * np.cos(angle) * (1 - u) + radius * np.cos(angle + 2*np.pi/num_faces) * u
                           y = -radius + v * (2 * radius + height_variation)
                           z = radius * np.sin(angle) * (1 - u) + radius * np.sin(angle + 2*np.pi/num_faces) * u
                           
                           # Crystal colors
                           r = 0.3 + 0.7 * np.sin(angle + u * np.pi)
                           g = 0.4 + 0.6 * np.cos(v * np.pi)
                           b = 0.8 + 0.2 * np.sin(angle * 2)
                           alpha = 0.6  # More transparent for crystal effect
                           
                           vertices.extend([x, y, z, r, g, b, alpha])
                   
                   # Create triangles for this face
                   for i in range(subdivisions):
                       for j in range(subdivisions):
                           base = face_start + i * (subdivisions + 1) + j
                           indices.extend([base, base + 1, base + subdivisions + 1])
                           indices.extend([base + 1, base + subdivisions + 2, base + subdivisions + 1])
               
               return vertices, indices
       
    1:     def create_room(self):
               """Create the room geometry based on selected type"""
    1:         try:
    1:             if self.room_type == 0:
    1:                 vertices, indices = self.create_cube_room()
                   elif self.room_type == 1:
                       vertices, indices = self.create_sphere_room()
                   elif self.room_type == 2:
                       vertices, indices = self.create_tunnel_room()
                   elif self.room_type == 3:
                       vertices, indices = self.create_pyramid_room()
                   else:
                       vertices, indices = self.create_crystal_room()
                   
    1:             self.vertices = np.array(vertices, dtype=np.float32)
    1:             self.indices = np.array(indices, dtype=np.uint32)
    1:             self.original_vertices = self.vertices.copy()
                   
    1:             self.setup_buffers()
                   
               except Exception as e:
                   print(f"Error creating room: {e}")
                   # Fallback geometry
                   self.vertices = np.array([
                       -5, -5, -5, 1, 0, 0, 0.8,
                        5, -5, -5, 0, 1, 0, 0.8,
                        5,  5, -5, 0, 0, 1, 0.8,
                       -5,  5, -5, 1, 1, 0, 0.8
                   ], dtype=np.float32)
                   self.indices = np.array([0, 1, 2, 0, 2, 3], dtype=np.uint32)
                   self.original_vertices = self.vertices.copy()
                   self.setup_buffers()
       
    1:     def setup_buffers(self):
               """Setup OpenGL buffers"""
    1:         try:
    1:             if self.VAO:
                       glDeleteVertexArrays(1, [self.VAO])
    1:             if self.VBO:
                       glDeleteBuffers(1, [self.VBO])
    1:             if self.EBO:
                       glDeleteBuffers(1, [self.EBO])
       
    1:             self.VAO = glGenVertexArrays(1)
    1:             glBindVertexArray(self.VAO)
       
    1:             self.VBO = glGenBuffers(1)
    1:             glBindBuffer(GL_ARRAY_BUFFER, self.VBO)
    1:             glBufferData(GL_ARRAY_BUFFER, self.vertices.nbytes, self.vertices, GL_DYNAMIC_DRAW)
       
    1:             glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 7 * ctypes.sizeof(GLfloat), ctypes.c_void_p(0))
    1:             glEnableVertexAttribArray(0)
                   
    1:             glVertexAttribPointer(1, 4, GL_FLOAT, GL_FALSE, 7 * ctypes.sizeof(GLfloat), ctypes.c_void_p(3 * ctypes.sizeof(GLfloat)))
    1:             glEnableVertexAttribArray(1)
       
    1:             self.EBO = glGenBuffers(1)
    1:             glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, self.EBO)
    1:             glBufferData(GL_ELEMENT_ARRAY_BUFFER, self.indices.nbytes, self.indices, GL_STATIC_DRAW)
       
    1:             glBindVertexArray(0)
               except Exception as e:
                   print(f"Buffer setup error: {e}")
       
    1:     def apply_wall_effects(self):
               """Apply visual effects to the walls based on effect mode"""
   22:         if self.original_vertices is None:
                   return
                   
   22:         try:
   22:             vertex_count = len(self.vertices) // 7
                   
58234:             for i in range(vertex_count):
58212:                 idx = i * 7
58212:                 if idx + 6 >= len(self.vertices):
                           break
                       
                       # Get original position and color
58212:                 orig_x = self.original_vertices[idx]
58212:                 orig_y = self.original_vertices[idx + 1]
58212:                 orig_z = self.original_vertices[idx + 2]
58212:                 orig_r = self.original_vertices[idx + 3]
58212:                 orig_g = self.original_vertices[idx + 4]
58212:                 orig_b = self.original_vertices[idx + 5]
58212:                 orig_a = self.original_vertices[idx + 6]
                       
                       # Apply different effects based on mode
58212:                 if self.effect_mode == 0:  # Wave Patterns
58212:                     wave_x = np.sin(self.time * self.speed + orig_x * 0.5) * 0.3 * self.intensity
58212:                     wave_y = np.cos(self.time * self.speed + orig_y * 0.5) * 0.3 * self.intensity
58212:                     wave_z = np.sin(self.time * self.speed + orig_z * 0.5) * 0.3 * self.intensity
                           
58212:                     color_wave = 0.5 + 0.5 * np.sin(self.time * self.speed * 2 + orig_x + orig_y + orig_z)
                           
                       elif self.effect_mode == 1:  # Fractal Growth
                           distance = np.sqrt(orig_x**2 + orig_y**2 + orig_z**2)
                           fractal = np.sin(distance * 0.3 + self.time * self.speed) * self.intensity
                           
                           wave_x = fractal * 0.2
                           wave_y = fractal * 0.2
                           wave_z = fractal * 0.2
                           
                           color_wave = 0.5 + 0.5 * fractal
                           
                       elif self.effect_mode == 2:  # Mirror Kaleidoscope
                           angle = np.arctan2(orig_z, orig_x)
                           radius = np.sqrt(orig_x**2 + orig_z**2)
                           
                           mirror_angle = angle * 3 + self.time * self.speed
                           kaleidoscope = np.sin(mirror_angle) * np.cos(radius * 0.2 + self.time * self.speed)
                           
                           wave_x = kaleidoscope * 0.5 * self.intensity
                           wave_y = kaleidoscope * 0.3 * self.intensity
                           wave_z = kaleidoscope * 0.5 * self.intensity
                           
                           color_wave = 0.5 + 0.5 * kaleidoscope
                           
                       elif self.effect_mode == 3:  # Digital Rain
                           rain = np.sin(self.time * self.speed * 5 + orig_x * 2 + orig_z * 2) * self.intensity
                           
                           wave_x = 0
                           wave_y = rain * 0.2
                           wave_z = 0
                           
                           # Digital green effect
                           color_wave = 0.3 + 0.7 * np.abs(rain)
                           
                       else:  # Plasma Flow
                           plasma_x = np.sin(orig_x * 0.2 + self.time * self.speed)
                           plasma_y = np.cos(orig_y * 0.2 + self.time * self.speed * 1.3)
                           plasma_z = np.sin(orig_z * 0.2 + self.time * self.speed * 0.7)
                           
                           plasma = plasma_x * plasma_y * plasma_z * self.intensity
                           
                           wave_x = plasma * 0.3
                           wave_y = plasma * 0.3
                           wave_z = plasma * 0.3
                           
                           color_wave = 0.5 + 0.5 * plasma
                       
                       # Apply position changes (subtle, just on surface)
58212:                 self.vertices[idx] = orig_x + wave_x
58212:                 self.vertices[idx + 1] = orig_y + wave_y
58212:                 self.vertices[idx + 2] = orig_z + wave_z
                       
                       # Apply color changes
58212:                 if self.effect_mode == 3:  # Digital Rain - green
                           self.vertices[idx + 3] = 0.1 * color_wave
                           self.vertices[idx + 4] = 0.9 * color_wave
                           self.vertices[idx + 5] = 0.3 * color_wave
                       else:
58212:                     self.vertices[idx + 3] = np.clip(orig_r * (0.5 + 0.5 * color_wave), 0, 1)
58212:                     self.vertices[idx + 4] = np.clip(orig_g * (0.5 + 0.5 * np.sin(color_wave + 2)), 0, 1)
58212:                     self.vertices[idx + 5] = np.clip(orig_b * (0.5 + 0.5 * np.cos(color_wave + 4)), 0, 1)
                       
                       # Keep original alpha for transparency
58212:                 self.vertices[idx + 6] = orig_a
       
                   # Update buffer
   22:             glBindBuffer(GL_ARRAY_BUFFER, self.VBO)
   22:             glBufferSubData(GL_ARRAY_BUFFER, 0, self.vertices.nbytes, self.vertices)
   22:             glBindBuffer(GL_ARRAY_BUFFER, 0)
                   
               except Exception as e:
                   print(f"Effect application error: {e}")
       
    1:     def resizeGL(self, width, height):
    1:         if height == 0:
                   height = 1
    1:         glViewport(0, 0, width, height)
       
    1:     def paintGL(self):
               # CLEAR WITH TRANSPARENT BACKGROUND
   22:         glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
               
   22:         if self.shader_program is None or self.VAO is None:
                   return
                   
   22:         try:
   22:             glUseProgram(self.shader_program)
       
                   # Update time and effects
   22:             self.time += 0.016
   22:             self.apply_wall_effects()
       
                   # FIXED CAMERA - you're inside looking around
                   # Camera is at origin, looking in different directions slightly
   22:             camera_pos = [0, 0, 0]  # Fixed at center
                   
                   # Slight rotation to see the room better
   22:             look_x = np.sin(self.time * 0.1) * 0.3
   22:             look_y = np.cos(self.time * 0.07) * 0.2
   22:             look_z = np.cos(self.time * 0.13) * 0.3
                   
   22:             look_at = [look_x, look_y, look_z]
       
                   # Fixed matrices - room doesn't move
   22:             projection = self.perspective(90, 1.0, 0.1, 50.0)  # Wide FOV to see the room
   44:             view = self.lookAt(
   22:                 np.array(camera_pos),
   22:                 np.array(look_at),
   22:                 np.array([0, 1, 0])
                   )
   22:             model = np.identity(4, dtype=np.float32)  # No movement
       
                   # Set uniforms
   22:             proj_loc = glGetUniformLocation(self.shader_program, "projection")
   22:             view_loc = glGetUniformLocation(self.shader_program, "view")
   22:             model_loc = glGetUniformLocation(self.shader_program, "model")
                   
   22:             if proj_loc != -1:
   22:                 glUniformMatrix4fv(proj_loc, 1, GL_FALSE, projection)
   22:             if view_loc != -1:
   22:                 glUniformMatrix4fv(view_loc, 1, GL_FALSE, view)
   22:             if model_loc != -1:
   22:                 glUniformMatrix4fv(model_loc, 1, GL_FALSE, model)
       
                   # Draw the room
   22:             glBindVertexArray(self.VAO)
   22:             glDrawElements(GL_TRIANGLES, len(self.indices), GL_UNSIGNED_INT, None)
   22:             glBindVertexArray(0)
       
               except Exception as e:
                   print(f"Paint error: {e}")
       
    1:     def perspective(self, fov, aspect, near, far):
   22:         f = 1.0 / np.tan(np.radians(fov / 2.0))
   66:         return np.array([
   22:             [f / aspect, 0.0, 0.0, 0.0],
   22:             [0.0, f, 0.0, 0.0],
   22:             [0.0, 0.0, (far + near) / (near - far), -1.0],
   22:             [0.0, 0.0, (2.0 * far * near) / (near - far), 0.0]
   22:         ], dtype=np.float32)
       
    1:     def lookAt(self, eye, center, up):
   22:         try:
   22:             f = (center - eye) / np.linalg.norm(center - eye)
   22:             s = np.cross(f, up) / np.linalg.norm(np.cross(f, up))
   22:             u = np.cross(s, f)
       
   88:             return np.array([
   22:                 [s[0], u[0], -f[0], 0.0],
   22:                 [s[1], u[1], -f[1], 0.0],
   22:                 [s[2], u[2], -f[2], 0.0],
   22:                 [-np.dot(s, eye), -np.dot(u, eye), np.dot(f, eye), 1.0]
   44:             ], dtype=np.float32).T
               except:
                   return np.identity(4, dtype=np.float32)
       
    1:     def cleanup(self):
    1:         print("Cleaning up BuildingMadnessVisualizer")
    1:         try:
    1:             if self.shader_program:
    1:                 glDeleteProgram(self.shader_program)
    1:                 self.shader_program = None
    1:             if self.VBO:
    1:                 glDeleteBuffers(1, [self.VBO])
    1:                 self.VBO = None
    1:             if self.VAO:
    1:                 glDeleteVertexArrays(1, [self.VAO])
    1:                 self.VAO = None
    1:             if self.EBO:
    1:                 glDeleteBuffers(1, [self.EBO])
    1:                 self.EBO = None
               except Exception as e:
                   print(f"Error during cleanup: {e}")
