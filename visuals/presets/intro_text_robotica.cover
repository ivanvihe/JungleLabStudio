       # visuals/presets/intro_text_robotica.py - COMPLETE FIXED VERSION
    1: import logging
    1: import numpy as np
    1: import ctypes
    1: import time
    1: import random
    1: from OpenGL.GL import *  # Legacy fallback
    1: from ..base_visualizer import BaseVisualizer
    1: from ..render_backend import GLBackend
       
    2: class IntroTextRoboticaVisualizer(BaseVisualizer):
    1:     """Overlay visualizer that displays the text 'R O B O T I C A' with a transparent background."""
       
    1:     visual_name = "Intro Text ROBOTICA"
       
           # 5x7 block font patterns for required letters
    1:     LETTER_PATTERNS = {
    1:         "R": [
                   "11110",
                   "10001",
                   "10001",
                   "11110",
                   "10100",
                   "10010",
                   "10001",
               ],
    1:         "O": [
                   "01110",
                   "10001",
                   "10001",
                   "10001",
                   "10001",
                   "10001",
                   "01110",
               ],
    1:         "B": [
                   "11110",
                   "10001",
                   "10001",
                   "11110",
                   "10001",
                   "10001",
                   "11110",
               ],
    1:         "T": [
                   "11111",
                   "00100",
                   "00100",
                   "00100",
                   "00100",
                   "00100",
                   "00100",
               ],
    1:         "I": [
                   "11111",
                   "00100",
                   "00100",
                   "00100",
                   "00100",
                   "00100",
                   "11111",
               ],
    1:         "C": [
                   "01110",
                   "10001",
                   "10000",
                   "10000",
                   "10000",
                   "10001",
                   "01110",
               ],
    1:         "A": [
                   "01110",
                   "10001",
                   "10001",
                   "11111",
                   "10001",
                   "10001",
                   "10001",
               ],
           }
       
    1:     def __init__(self):
    1:         super().__init__()
    1:         self.text = "R O B O T I C A"
    1:         self.initialized = False
    1:         self.shader_program = None
    1:         self.vao = None
    1:         self.vbo = None
    1:         self.vertices = None
    1:         self.vertex_count = 0
               
               # Visual parameters
    1:         self.text_alpha = 1.0
    1:         self.text_scale = 1.0
    1:         self.text_color = [1.0, 1.0, 1.0]  # White by default
               
               # Animation parameters for cinematic effect
    1:         self.start_time = None
    1:         self.animation_duration = 15.0  # Total animation duration in seconds
    1:         self.fade_duration = 6.0        # How long each letter takes to fade in (5-10 seconds)
    1:         self.letter_delay = 0.3         # Much faster start between letters
               
               # Letter animation order (random as requested: O T B O I A C R)
               # "R O B O T I C A" -> indices: 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15
               #  R   O   B   O   T   I   C   A  (skipping spaces at 1,3,5,7,9,11,13,15)
               #  0   2   4   6   8  10  12  14
    1:         self.animation_order = [2, 8, 4, 6, 10, 14, 12, 0]  # O T B O I A C R
               # Corresponds to:     O  T  B  O  I  A  C  R
               
               # Track individual letter alphas for animation
    1:         self.letter_alphas = [0.0] * len(self.text)
    1:         self.letter_start_times = [None] * len(self.text)
               
    1:         logging.info("IntroTextRoboticaVisualizer created")
       
    1:     def initializeGL(self, backend=None):
               """Initialize OpenGL resources using the provided backend."""
    1:         self.backend = backend or GLBackend()
    1:         try:
    1:             logging.debug("IntroTextRoboticaVisualizer.initializeGL called")
       
    1:             if not self.load_shaders():
                       logging.error("Failed to load shaders")
                       return
       
    1:             if not self.setup_text_geometry():
                       logging.error("Failed to setup text geometry")
                       return
       
    1:             self.initialized = True
    1:             logging.info("âœ… IntroTextRoboticaVisualizer initialized successfully")
       
               except Exception as e:
                   logging.error(f"Error in IntroTextRoboticaVisualizer.initializeGL: {e}")
                   import traceback
                   traceback.print_exc()
       
    1:     def load_shaders(self):
               """Load and compile shaders for text rendering"""
    1:         try:
    1:             vertex_shader_source = """
                   #version 330 core
                   layout (location = 0) in vec2 aPos;
                   layout (location = 1) in float aLetterIndex;
       
                   uniform float globalAlpha;
                   uniform float scale;
                   uniform vec3 color;
                   uniform float letterAlphas[16];  // Max 16 letters including spaces
                   uniform float time;
       
                   out vec3 textColor;
                   out float textAlpha;
       
                   void main()
                   {
                       vec2 scaledPos = aPos * scale;
                       gl_Position = vec4(scaledPos, 0.0, 1.0);
                       textColor = color;
       
                       // Get individual letter alpha
                       int letterIdx = int(aLetterIndex);
                       float letterAlpha = (letterIdx >= 0 && letterIdx < 16) ? letterAlphas[letterIdx] : 0.0;
       
                       // Add subtle glow effect during fade-in
                       float glow = 1.0 + 0.3 * sin(time * 4.0) * letterAlpha;
       
                       textAlpha = globalAlpha * letterAlpha * glow;
                   }
                   """
       
    1:             fragment_shader_source = """
                   #version 330 core
                   in vec3 textColor;
                   in float textAlpha;
       
                   out vec4 FragColor;
       
                   void main()
                   {
                       FragColor = vec4(textColor, textAlpha);
                   }
                   """
       
    2:             self.shader_program = self.backend.program(
    1:                 vertex_shader_source, fragment_shader_source
                   )
       
    1:             logging.debug("IntroTextRoboticaVisualizer shaders compiled successfully")
    1:             return True
       
               except Exception as e:
                   logging.error(f"Error loading shaders: {e}")
                   return False
       
    1:     def setup_text_geometry(self):
               """Setup vertex data for the text 'ROBOTICA' - FIXED SIZE"""
    1:         try:
    1:             vertices = []
       
    1:             letter_height = 0.18
    1:             cell_size = letter_height / 7.0
    1:             letter_width = 5 * cell_size
    1:             letter_spacing = cell_size * 0.6
    1:             word_spacing = cell_size * 1.8
       
    1:             total_width = 0.0
   16:             for char in self.text:
   15:                 if char == ' ':
    7:                     total_width += word_spacing
                       else:
    8:                     total_width += letter_width + letter_spacing
    1:             total_width -= letter_spacing
       
    1:             start_x = -total_width / 2.0
    1:             start_y = -letter_height / 2.0
       
    1:             current_x = start_x
    1:             letter_index = 0
       
   16:             for char_idx, char in enumerate(self.text):
   15:                 if char == ' ':
    7:                     current_x += word_spacing
    7:                     continue
       
    8:                 pattern = self.LETTER_PATTERNS.get(char)
    8:                 if pattern:
   16:                     letter_vertices = self.generate_letter_vertices(
    8:                         pattern, current_x, start_y, cell_size, char_idx
                           )
    8:                     vertices.extend(letter_vertices)
       
    8:                 current_x += letter_width + letter_spacing
    8:                 letter_index += 1
       
    1:             if not vertices:
                       logging.error("No vertices generated for text")
                       return False
       
    1:             self.vertices = np.array(vertices, dtype=np.float32)
    1:             self.vertex_count = len(vertices) // 3
       
    1:             self.vbo = self.backend.buffer(self.vertices.tobytes())
    2:             self.vao = self.backend.vertex_array(
    1:                 self.shader_program,
    1:                 [(self.vbo, '2f 1f', 'aPos', 'aLetterIndex')],
                   )
       
    1:             logging.debug(f"Text geometry setup complete: {self.vertex_count} vertices")
    1:             return True
       
               except Exception as e:
                   logging.error(f"Error setting up text geometry: {e}")
                   return False
       
    1:     def generate_letter_vertices(self, pattern, start_x, start_y, cell_size, letter_index):
               """Generate vertices for a single letter based on its pattern"""
    8:         vertices = []
               
   64:         for row_idx, row_data in enumerate(pattern):
  336:             for col_idx, pixel in enumerate(row_data):
  280:                 if pixel == '1':
                           # Calculate cell position
  127:                     x = start_x + col_idx * cell_size
  127:                     y = start_y + (len(pattern) - row_idx - 1) * cell_size
                           
                           # Create a quad (2 triangles) for this cell
                           # Each vertex: [x, y, letterIndex]
                           
                           # Triangle 1
  254:                     vertices.extend([
  127:                         x, y, float(letter_index),                           # Bottom-left
  127:                         x + cell_size, y, float(letter_index),              # Bottom-right
  127:                         x, y + cell_size, float(letter_index)               # Top-left
                           ])
                           
                           # Triangle 2
  254:                     vertices.extend([
  127:                         x + cell_size, y, float(letter_index),              # Bottom-right
  127:                         x + cell_size, y + cell_size, float(letter_index),  # Top-right
  127:                         x, y + cell_size, float(letter_index)               # Top-left
                           ])
               
    8:         return vertices
       
    1:     def update_animation(self, current_time):
               """Update the cinematic letter animation"""
  761:         if self.start_time is None:
    1:             self.start_time = current_time
                   # Initialize letter start times based on animation order
    9:             for i, letter_idx in enumerate(self.animation_order):
    8:                 if letter_idx < len(self.text) and self.text[letter_idx] != ' ':
                           # Much faster start with less randomness
    8:                     delay = i * self.letter_delay + random.uniform(-0.1, 0.1)
    8:                     self.letter_start_times[letter_idx] = self.start_time + delay
    8:                     logging.debug(f"Letter {self.text[letter_idx]} (idx {letter_idx}) will start at {delay:.2f}s")
               
               # Update each letter's alpha based on its start time
12176:         for letter_idx, start_time in enumerate(self.letter_start_times):
11415:             if start_time is not None and current_time >= start_time:
                       # Calculate fade progress
 5795:                 fade_progress = (current_time - start_time) / self.fade_duration
 5795:                 fade_progress = min(1.0, max(0.0, fade_progress))
                       
                       # Smooth fade curve (ease-out)
 5795:                 fade_progress = 1.0 - (1.0 - fade_progress) ** 2
                       
 5795:                 self.letter_alphas[letter_idx] = fade_progress
                       
                       # Debug logging for first few seconds
 5795:                 if fade_progress < 1.0:
 1746:                     logging.debug(f"Letter {self.text[letter_idx]} fade: {fade_progress:.2f}")
           
    1:     def reset_animation(self):
               """Reset the animation to start from beginning"""
               self.start_time = None
               self.letter_alphas = [0.0] * len(self.text)
               self.letter_start_times = [None] * len(self.text)
               logging.info("Animation reset - all letters will restart")
       
    1:     def paintGL(self, current_time=0.0, size=None, backend=None):
               """Render the text using the backend with cinematic animation"""
  761:         backend = backend or self.backend or GLBackend()
  761:         try:
  761:             if not self.initialized or not self.shader_program or not self.vao:
                       backend.clear(0.0, 0.0, 0.0, 0.0)
                       return
       
  761:             backend.clear(0.0, 0.0, 0.0, 0.0)
       
  761:             self.update_animation(current_time)
       
  761:             backend.uniform(self.shader_program, "globalAlpha", self.text_alpha)
                   backend.uniform(self.shader_program, "scale", self.text_scale)
                   backend.uniform(self.shader_program, "color", self.text_color)
                   backend.uniform(self.shader_program, "time", current_time)
       
                   alphas_array = self.letter_alphas + [0.0] * (16 - len(self.letter_alphas))
                   backend.uniform(self.shader_program, "letterAlphas", alphas_array)
       
                   self.vao.render()
       
  761:         except Exception as e:
  761:             if not hasattr(self, '_last_error_time') or \
  760:                time.time() - self._last_error_time > 5:
    5:                 logging.error(f"IntroTextRobotica paint error: {e}")
    5:                 self._last_error_time = time.time()
       
  761:             backend.clear(0.0, 0.0, 0.0, 0.0)
       
    1:     def resizeGL(self, width, height, backend=None):
               """Handle resize"""
    1:         if backend:
    1:             backend.set_viewport(0, 0, width, height)
               else:
                   glViewport(0, 0, width, height)
       
    1:     def cleanup(self):
               """Clean up OpenGL resources"""
    1:         try:
    1:             logging.debug("Cleaning up IntroTextRoboticaVisualizer")
       
    1:             if self.vao:
    1:                 if hasattr(self.vao, "release"):
                           try:
                               self.vao.release()
                           except Exception:
                               pass
                       else:
    1:                     try:
    1:                         glDeleteVertexArrays(1, [self.vao.vao])
                           except Exception:
                               pass
    1:                 self.vao = None
       
    1:             if self.vbo:
    1:                 if hasattr(self.vbo, "release"):
                           try:
                               self.vbo.release()
                           except Exception:
                               pass
                       else:
    1:                     try:
    1:                         glDeleteBuffers(1, [self.vbo.buffer_id])
                           except Exception:
                               pass
    1:                 self.vbo = None
       
    1:             if self.shader_program:
    1:                 if hasattr(self.shader_program, "release"):
                           try:
                               self.shader_program.release()
                           except Exception:
                               pass
                       else:
    1:                     try:
    1:                         if glIsProgram(self.shader_program):
    1:                             glDeleteProgram(self.shader_program)
                           except Exception:
                               pass
    1:                 self.shader_program = None
       
    1:             self.initialized = False
    1:             logging.debug("IntroTextRoboticaVisualizer cleanup complete")
       
               except Exception as e:
                   logging.debug(f"Cleanup error (non-critical): {e}")
       
    1:     def get_controls(self):
               """Return available controls"""
    2:         return {
    2:             "Text Alpha": {
    2:                 "type": "slider",
    2:                 "min": 0,
    2:                 "max": 100,
    2:                 "value": int(self.text_alpha * 100),
    2:                 "default": 100
                   },
    2:             "Text Scale": {
    2:                 "type": "slider",
    2:                 "min": 10,
    2:                 "max": 200,
    2:                 "value": int(self.text_scale * 100),
    2:                 "default": 100
                   },
    2:             "Animation Speed": {
    2:                 "type": "slider",
    2:                 "min": 10,
    2:                 "max": 100,
    2:                 "value": int((1.0 - self.letter_delay) * 100),  # Fixed calculation
    2:                 "default": 70
                   },
    2:             "Fade Duration": {
    2:                 "type": "slider",
    2:                 "min": 20,
    2:                 "max": 100,
    2:                 "value": int(self.fade_duration * 10),
    2:                 "default": 60
                   },
    2:             "Red": {
    2:                 "type": "slider",
    2:                 "min": 0,
    2:                 "max": 100,
    2:                 "value": int(self.text_color[0] * 100),
    2:                 "default": 100
                   },
    2:             "Green": {
    2:                 "type": "slider",
    2:                 "min": 0,
    2:                 "max": 100,
    2:                 "value": int(self.text_color[1] * 100),
    2:                 "default": 100
                   },
    2:             "Blue": {
    2:                 "type": "slider",
    2:                 "min": 0,
    2:                 "max": 100,
    2:                 "value": int(self.text_color[2] * 100),
    2:                 "default": 100
                   }
               }
       
    1:     def update_control(self, name, value):
               """Update a control value"""
               try:
                   if name == "Text Alpha":
                       self.text_alpha = value / 100.0
                       logging.debug(f"Text alpha updated to {self.text_alpha}")
                   elif name == "Text Scale":
                       self.text_scale = value / 100.0
                       logging.debug(f"Text scale updated to {self.text_scale}")
                   elif name == "Animation Speed":
                       self.letter_delay = 1.0 - (value / 100.0)  # Fixed: higher value = faster
                       logging.debug(f"Animation speed updated: letter_delay = {self.letter_delay}")
                   elif name == "Fade Duration":
                       self.fade_duration = value / 10.0
                       logging.debug(f"Fade duration updated to {self.fade_duration}")
                   elif name == "Red":
                       self.text_color[0] = value / 100.0
                       logging.debug(f"Red color updated to {self.text_color[0]}")
                   elif name == "Green":
                       self.text_color[1] = value / 100.0
                       logging.debug(f"Green color updated to {self.text_color[1]}")
                   elif name == "Blue":
                       self.text_color[2] = value / 100.0
                       logging.debug(f"Blue color updated to {self.text_color[2]}")
               except Exception as e:
                   logging.error(f"Error updating control {name}: {e}")
           
    1:     def trigger_action(self, action_name):
               """Handle custom actions triggered via MIDI"""
               if action_name == "restart_animation":
                   self.reset_animation()
                   logging.info("Animation restarted")
