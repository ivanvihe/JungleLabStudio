       # TODO: migrate to RenderBackend (ModernGL)
    1: from PyQt6.QtGui import QOpenGLContext, QSurfaceFormat
    1: from OpenGL.GL import *
    1: from OpenGL.GLU import *
    1: import numpy as np
    1: import ctypes
    1: import os
    1: import logging
       
    1: from visuals.base_visualizer import BaseVisualizer
       
    2: class GeometricParticlesVisualizer(BaseVisualizer):
    1:     visual_name = "Geometric Particles"
    1:     def __init__(self, parent=None):
    1:         super().__init__(parent)
               
    1:         self.shader_program = None
    1:         self.VBO = None
    1:         self.VAO = None
    1:         self.num_particles = 10000
    1:         self.particle_data = None
    1:         self.time = 0.0
    1:         self.point_size = 2.0
    1:         self.shape_type = 0
       
    1:     def get_controls(self):
    2:         return {
    2:             "Particle Count": {
    2:                 "type": "slider", "min": 1000, "max": 50000, "value": self.num_particles
                   },
    2:             "Point Size": {
    2:                 "type": "slider", "min": 1, "max": 10, "value": int(self.point_size)
                   },
    2:             "Shape Type": {
    2:                 "type": "dropdown", "options": ["Pulsating Sphere", "Animated Torus", "Abstract Cloud"], "value": self.shape_type
                   }
               }
       
    1:     def update_control(self, name, value):
               if name == "Particle Count":
                   self.num_particles = int(value)
                   self.setup_particles() # Re-initialize particles
               elif name == "Point Size":
                   self.point_size = float(value)
               elif name == "Shape Type":
                   self.shape_type = value
       
    1:     def initializeGL(self):
               # TRANSPARENT BACKGROUND FOR MIXING
    1:         glClearColor(0.0, 0.0, 0.0, 0.0)  # Alpha = 0 for transparency
    1:         glEnable(GL_DEPTH_TEST)
    1:         glEnable(GL_PROGRAM_POINT_SIZE)
    1:         glEnable(GL_BLEND)
    1:         glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
       
    1:         self.load_shaders()
    1:         self.setup_particles()
       
    1:     def load_shaders(self):
    1:         script_dir = os.path.dirname(__file__)
    1:         shader_dir = os.path.join(script_dir, '..', '..', 'shaders')
       
    2:         with open(os.path.join(shader_dir, 'basic.vert'), 'r') as f:
    1:             vertex_shader_source = f.read()
    2:         with open(os.path.join(shader_dir, 'basic.frag'), 'r') as f:
    1:             fragment_shader_source = f.read()
       
    1:         vertex_shader = glCreateShader(GL_VERTEX_SHADER)
    1:         glShaderSource(vertex_shader, vertex_shader_source)
    1:         glCompileShader(vertex_shader)
    1:         if not glGetShaderiv(vertex_shader, GL_COMPILE_STATUS):
                   print("Vertex Shader Compile Error:", glGetShaderInfoLog(vertex_shader).decode())
       
    1:         fragment_shader = glCreateShader(GL_FRAGMENT_SHADER)
    1:         glShaderSource(fragment_shader, fragment_shader_source)
    1:         glCompileShader(fragment_shader)
    1:         if not glGetShaderiv(fragment_shader, GL_COMPILE_STATUS):
                   print("Fragment Shader Compile Error:", glGetShaderInfoLog(fragment_shader).decode())
       
    1:         self.shader_program = glCreateProgram()
    1:         glAttachShader(self.shader_program, vertex_shader)
    1:         glAttachShader(self.shader_program, fragment_shader)
    1:         glLinkProgram(self.shader_program)
    1:         if not glGetProgramiv(self.shader_program, GL_LINK_STATUS):
                   print("Shader Program Link Error:", glGetProgramInfoLog(self.shader_program).decode())
       
    1:         glDeleteShader(vertex_shader)
    1:         glDeleteShader(fragment_shader)
       
    1:     def setup_particles(self):
               # Ensure VBO and VAO are deleted before re-creating
    1:         if self.VBO:
                   glDeleteBuffers(1, [self.VBO])
                   self.VBO = None # Set to None after deletion
    1:         if self.VAO:
                   glDeleteVertexArrays(1, [self.VAO])
                   self.VAO = None # Set to None after deletion
       
               # position (3) + color (4)
    1:         self.particle_data = np.zeros((self.num_particles, 7), dtype=np.float32)
       
    1:         self.VAO = glGenVertexArrays(1)
    1:         glBindVertexArray(self.VAO)
       
    1:         self.VBO = glGenBuffers(1)
    1:         glBindBuffer(GL_ARRAY_BUFFER, self.VBO)
    1:         glBufferData(GL_ARRAY_BUFFER, self.particle_data.nbytes, self.particle_data, GL_DYNAMIC_DRAW)
       
               # Position
    1:         glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 7 * ctypes.sizeof(GLfloat), ctypes.c_void_p(0))
    1:         glEnableVertexAttribArray(0)
               # Color
    1:         glVertexAttribPointer(1, 4, GL_FLOAT, GL_FALSE, 7 * ctypes.sizeof(GLfloat), ctypes.c_void_p(3 * ctypes.sizeof(GLfloat)))
    1:         glEnableVertexAttribArray(1)
       
    1:         glBindBuffer(GL_ARRAY_BUFFER, 0)
    1:         glBindVertexArray(0)
       
    1:     def update_particles(self):
  273:         self.time += 0.01
       
2730273:         for i in range(self.num_particles):
                   # Parametric equations for different shapes
2730000:             u = (i / self.num_particles) * 2 * np.pi * 10 # Increase frequency for more complex patterns
2730000:             v = np.sin(self.time + i / (self.num_particles / 50.0))
       
2730000:             if self.shape_type == 0:  # Pulsating Sphere
2730000:                 r = 1.5 + 0.5 * np.sin(self.time * 3.0 + u * 0.5)
2730000:                 x = r * np.cos(u) * np.sqrt(1 - v**2)
2730000:                 y = r * np.sin(u) * np.sqrt(1 - v**2)
2730000:                 z = r * v
                   elif self.shape_type == 1:  # Animated Torus
                       R = 2.0
                       r = 0.5 + 0.2 * np.sin(self.time * 2.0 + u)
                       x = (R + r * np.cos(u)) * np.cos(v * 2 * np.pi)
                       y = (R + r * np.cos(u)) * np.sin(v * 2 * np.pi)
                       z = r * np.sin(u)
                   else:  # Abstract "Cloud"
                       x = np.sin(u * 3.0 + self.time) * 2.0
                       y = np.cos(v * 5.0 - self.time) * 2.0
                       z = np.sin(u * 2.0 + v * 3.0 + self.time) * 2.0
       
2730000:             self.particle_data[i, 0:3] = [x, y, z]
       
                   # Color based on position and time with transparency
2730000:             r_color = 0.6 + 0.4 * np.sin(x + self.time)
2730000:             g_color = 0.6 + 0.4 * np.cos(y + self.time)
2730000:             b_color = 0.6 + 0.4 * np.sin(z + self.time)
                   # Make particles semi-transparent for better mixing
2730000:             alpha = 0.8
2730000:             self.particle_data[i, 3:7] = [r_color, g_color, b_color, alpha]
       
  273:         glBindBuffer(GL_ARRAY_BUFFER, self.VBO)
  273:         glBufferSubData(GL_ARRAY_BUFFER, 0, self.particle_data.nbytes, self.particle_data)
  273:         glBindBuffer(GL_ARRAY_BUFFER, 0)
       
    1:     def resizeGL(self, width, height):
    1:         glViewport(0, 0, width, height)
    1:         projection = self.perspective(45, (width / height) if height > 0 else 1, 0.1, 100.0)
    1:         glUseProgram(self.shader_program)
    1:         glUniformMatrix4fv(glGetUniformLocation(self.shader_program, "projection"), 1, GL_FALSE, projection)
       
    1:     def paintGL(self):
               # CLEAR WITH TRANSPARENT BACKGROUND
  273:         glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
  273:         glUseProgram(self.shader_program)
       
  273:         self.update_particles()
       
  273:         view = self.lookAt(np.array([0.0, 0.0, 10.0]), np.array([0.0, 0.0, 0.0]), np.array([0.0, 1.0, 0.0]))
  273:         model = self.rotate(self.time * 15, 0, 1, 0) @ self.rotate(self.time * 10, 1, 0, 0)
       
  273:         glUniformMatrix4fv(glGetUniformLocation(self.shader_program, "view"), 1, GL_FALSE, view)
  273:         glUniformMatrix4fv(glGetUniformLocation(self.shader_program, "model"), 1, GL_FALSE, model)
       
  273:         glPointSize(self.point_size)
       
  273:         glBindVertexArray(self.VAO)
  273:         glDrawArrays(GL_POINTS, 0, self.num_particles)
  273:         glBindVertexArray(0)
       
               
       
    1:     def perspective(self, fov, aspect, near, far):
    1:         f = 1.0 / np.tan(np.radians(fov / 2.0))
    3:         return np.array([
    1:             [f / aspect, 0.0, 0.0, 0.0],
    1:             [0.0, f, 0.0, 0.0],
    1:             [0.0, 0.0, (far + near) / (near - far), -1.0],
    1:             [0.0, 0.0, (2.0 * far * near) / (near - far), 0.0]
    1:         ], dtype=np.float32)
       
    1:     def lookAt(self, eye, center, up):
  273:         f = (center - eye) / np.linalg.norm(center - eye)
  273:         s = np.cross(f, up) / np.linalg.norm(np.cross(f, up))
  273:         u = np.cross(s, f)
       
 1092:         return np.array([
  273:             [s[0], u[0], -f[0], 0.0],
  273:             [s[1], u[1], -f[1], 0.0],
  273:             [s[2], u[2], -f[2], 0.0],
  273:             [-np.dot(s, eye), -np.dot(u, eye), np.dot(f, eye), 1.0]
  546:         ], dtype=np.float32).T
       
    1:     def rotate(self, angle, x, y, z):
  546:         angle = np.radians(angle)
  546:         c, s = np.cos(angle), np.sin(angle)
  546:         n = np.sqrt(x*x + y*y + z*z)
  546:         if n == 0: return np.identity(4)
  546:         x, y, z = x/n, y/n, z/n
 1638:         return np.array([
  546:             [c+(x**2)*(1-c), x*y*(1-c)-z*s, x*z*(1-c)+y*s, 0],
  546:             [y*x*(1-c)+z*s, c+(y**2)*(1-c), y*z*(1-c)-x*s, 0],
  546:             [z*x*(1-c)-y*s, z*y*(1-c)+x*s, c+(z**2)*(1-c), 0],
  546:             [0, 0, 0, 1]
  546:         ], dtype=np.float32)
       
    1:     def scale(self, x, y, z):
               return np.array([
                   [x, 0, 0, 0],
                   [0, y, 0, 0],
                   [0, 0, z, 0],
                   [0, 0, 0, 1]
               ], dtype=np.float32)
       
    1:     def cleanup(self):
    1:         logging.debug("Cleaning up GeometricParticlesVisualizer")
    1:         try:
    1:             if self.shader_program:
    1:                 glDeleteProgram(self.shader_program)
    1:                 self.shader_program = None
               except Exception as e:
                   logging.error(f"Error deleting shader program: {e}")
    1:         try:
    1:             if self.VBO:
    1:                 glDeleteBuffers(1, [self.VBO])
    1:                 self.VBO = None
               except Exception as e:
                   logging.error(f"Error deleting VBO: {e}")
    1:         try:
    1:             if self.VAO:
    1:                 glDeleteVertexArrays(1, [self.VAO])
    1:                 self.VAO = None
               except Exception as e:
                   logging.error(f"Error deleting VAO: {e}")
