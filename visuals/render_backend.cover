    1: from __future__ import annotations
       
    1: from dataclasses import dataclass
    1: from typing import Any, Tuple
    1: import ctypes
       
    1: from OpenGL.GL import (
           GL_ARRAY_BUFFER,
           GL_BLEND,
           GL_COLOR_BUFFER_BIT,
           GL_DEPTH_BUFFER_BIT,
           GL_FALSE,
           GL_FLOAT,
           GL_FRAGMENT_SHADER,
           GL_LINK_STATUS,
           GL_STATIC_DRAW,
           GL_TRIANGLES,
           GL_VERTEX_SHADER,
           glAttachShader,
           glBindBuffer,
           glBindVertexArray,
           glBlendFunc,
           glBufferData,
           glClear,
           glClearColor,
           glCompileShader,
           glCreateProgram,
           glCreateShader,
           glDeleteProgram,
           glDeleteShader,
           glDisable,
           glDrawArrays,
           glEnable,
           glEnableVertexAttribArray,
           glGenBuffers,
           glGenVertexArrays,
           glGetProgramInfoLog,
           glGetProgramiv,
           glGetShaderInfoLog,
           glGetShaderiv,
           glGetUniformLocation,
           glLinkProgram,
           glShaderSource,
           glUniform1f,
           glUniform1fv,
           glUniform2f,
           glUniform3f,
           glUniform4f,
           glUseProgram,
           glVertexAttribPointer,
           glViewport,
       )
       
       
    2: class RenderBackend:
    1:     """Abstract rendering backend."""
       
    1:     def ensure_context(self) -> None:  # pragma: no cover - interface
               pass
       
    1:     def begin_target(self, size: Tuple[int, int]) -> None:  # pragma: no cover - interface
               pass
       
    1:     def end_target(self) -> None:  # pragma: no cover - interface
               pass
       
    1:     def clear(self, r: float, g: float, b: float, a: float) -> None:  # pragma: no cover - interface
               pass
       
    1:     def program(self, vertex_src: str, fragment_src: str, **kwargs) -> Any:  # pragma: no cover
               pass
       
    1:     def buffer(self, data: bytes) -> Any:  # pragma: no cover
               pass
       
    5:     def vertex_array(
    4:         self, program: Any, content: Any, index_buffer: Any | None = None
    1:     ) -> Any:  # pragma: no cover
               pass
       
    1:     def set_viewport(self, x: int, y: int, w: int, h: int) -> None:  # pragma: no cover
               pass
       
    1:     def uniform(self, program: Any, name: str, value: Any) -> None:  # pragma: no cover
               pass
       
       
    3: @dataclass
    2: class GLBuffer:
    1:     buffer_id: int
    1:     size: int
       
       
    2: class GLVertexArray:
    1:     def __init__(self, program: int, vao: int, count: int) -> None:
    1:         self.program = program
    1:         self.vao = vao
    1:         self.count = count
       
    1:     def render(self, mode: int = GL_TRIANGLES) -> None:
               glUseProgram(self.program)
               glBindVertexArray(self.vao)
               glDrawArrays(mode, 0, self.count)
               glBindVertexArray(0)
               glUseProgram(0)
       
       
    2: class GLBackend(RenderBackend):
    1:     """Backend that forwards to classic OpenGL calls."""
       
    1:     def ensure_context(self) -> None:
 3136:         glEnable(GL_BLEND)
 3136:         glBlendFunc(1, 771)  # GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA
 3136:         glDisable(0x0B71)  # GL_DEPTH_TEST
       
    1:     def begin_target(self, size: Tuple[int, int]) -> None:
 3136:         self.set_viewport(0, 0, size[0], size[1])
       
    1:     def end_target(self) -> None:
 3136:         pass
       
    1:     def clear(self, r: float, g: float, b: float, a: float) -> None:
 4658:         glClearColor(r, g, b, a)
 4658:         glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
       
    1:     def program(self, vertex_src: str, fragment_src: str, **kwargs) -> int:
    1:         vs = glCreateShader(GL_VERTEX_SHADER)
    1:         glShaderSource(vs, vertex_src)
    1:         glCompileShader(vs)
    1:         if not glGetShaderiv(vs, 0x8B81):
                   error = glGetShaderInfoLog(vs).decode()
                   glDeleteShader(vs)
                   raise RuntimeError(f"Vertex shader compilation failed: {error}")
       
    1:         fs = glCreateShader(GL_FRAGMENT_SHADER)
    1:         glShaderSource(fs, fragment_src)
    1:         glCompileShader(fs)
    1:         if not glGetShaderiv(fs, 0x8B81):
                   error = glGetShaderInfoLog(fs).decode()
                   glDeleteShader(vs)
                   glDeleteShader(fs)
                   raise RuntimeError(f"Fragment shader compilation failed: {error}")
       
    1:         program = glCreateProgram()
    1:         glAttachShader(program, vs)
    1:         glAttachShader(program, fs)
    1:         glLinkProgram(program)
    1:         if not glGetProgramiv(program, GL_LINK_STATUS):
                   error = glGetProgramInfoLog(program).decode()
                   glDeleteShader(vs)
                   glDeleteShader(fs)
                   glDeleteProgram(program)
                   raise RuntimeError(f"Program link failed: {error}")
       
    1:         glDeleteShader(vs)
    1:         glDeleteShader(fs)
    1:         return program
       
    1:     def buffer(self, data: bytes) -> GLBuffer:
    1:         buf = glGenBuffers(1)
    1:         glBindBuffer(GL_ARRAY_BUFFER, buf)
    1:         glBufferData(GL_ARRAY_BUFFER, len(data), data, GL_STATIC_DRAW)
    1:         glBindBuffer(GL_ARRAY_BUFFER, 0)
    1:         return GLBuffer(buf, len(data))
       
    5:     def vertex_array(
    4:         self, program: int, content: Any, index_buffer: Any | None = None
    1:     ) -> GLVertexArray:
    1:         vao = glGenVertexArrays(1)
    1:         glBindVertexArray(vao)
       
    1:         buf, fmt, *attrs = content[0]
    1:         stride = 0
    1:         comps = []
    3:         for part in fmt.split():
    2:             num = int(part[:-1])
    2:             stride += num * 4
    2:             comps.append(num)
       
    1:         glBindBuffer(GL_ARRAY_BUFFER, buf.buffer_id)
    1:         offset = 0
    3:         for idx, num in enumerate(comps):
    2:             glEnableVertexAttribArray(idx)
    4:             glVertexAttribPointer(
    2:                 idx, num, GL_FLOAT, GL_FALSE, stride, ctypes.c_void_p(offset)
                   )
    2:             offset += num * 4
       
    1:         glBindVertexArray(0)
    1:         count = buf.size // stride
    1:         return GLVertexArray(program, vao, count)
       
    1:     def set_viewport(self, x: int, y: int, w: int, h: int) -> None:
 3145:         glViewport(x, y, w, h)
       
    1:     def uniform(self, program: int, name: str, value: Any) -> None:
  761:         loc = glGetUniformLocation(program, name)
  761:         if loc < 0:
                   return
  761:         if isinstance(value, (float, int)):
  761:             glUniform1f(loc, float(value))
               elif isinstance(value, (list, tuple)):
                   if len(value) == 2:
                       glUniform2f(loc, *value)
                   elif len(value) == 3:
                       glUniform3f(loc, *value)
                   elif len(value) == 4:
                       glUniform4f(loc, *value)
                   else:
                       glUniform1fv(loc, len(value), value)
       
       
    2: class ModernGLBackend(RenderBackend):
    1:     """Backend using moderngl. Context is created on demand."""
       
    1:     def __init__(self) -> None:
               self.ctx = None
               self.mgl = None
       
    1:     def ensure_context(self) -> None:
               if self.ctx is None:
                   import moderngl
       
                   self.mgl = moderngl
                   self.ctx = moderngl.create_context(require=330)
                   self.ctx.enable(moderngl.BLEND)
       
    1:     def begin_target(self, size: Tuple[int, int]) -> None:
               if self.ctx:
                   self.set_viewport(0, 0, size[0], size[1])
       
    1:     def end_target(self) -> None:
               pass
       
    1:     def clear(self, r: float, g: float, b: float, a: float) -> None:
               self.ctx.clear(r, g, b, a)
       
    1:     def program(self, vertex_src: str, fragment_src: str, **kwargs) -> Any:
               return self.ctx.program(
                   vertex_shader=vertex_src, fragment_shader=fragment_src, **kwargs
               )
       
    1:     def buffer(self, data: bytes) -> Any:
               return self.ctx.buffer(data)
       
    5:     def vertex_array(
    4:         self, program: Any, content: Any, index_buffer: Any | None = None
    1:     ) -> Any:
               return self.ctx.vertex_array(program, content, index_buffer=index_buffer)
       
    1:     def set_viewport(self, x: int, y: int, w: int, h: int) -> None:
               self.ctx.viewport = (x, y, w, h)
       
    1:     def uniform(self, program: Any, name: str, value: Any) -> None:
               if name not in program:
                   return
               uniform = program[name]
               if isinstance(value, (list, tuple)) and len(value) > 4:
                   import numpy as np
       
                   uniform.write(np.array(value, dtype="f4").tobytes())
               else:
                   uniform.value = value
       
